searchData={"items":[{"type":"module","title":"Journey","doc":"Journey is an Elixir library for building and executing computation graphs, with built-in persistence, reliability, and scalability.\n\nDefine your application workflows as dependency graphs where user inputs automatically trigger computations in the correct order, with all state persisted to PostgreSQL.\n\nExecutions of the graph survive crashes, redeploys, page reloads, while scaling naturally with your application - no additional infrastructure or cloud service$ required.\n\nYour application can perform durable, short or long-running executions, with retries, scalability, dependency tracking, scheduling and analytics.\n\nJourney's primitives are simple: graph, dependencies, functions, persistence, retries, scheduling. Together, they help you build rich, scalable, reliable functionality with simple, well-structured and easy-to-understand code, quickly.","ref":"Journey.html"},{"type":"module","title":"Overview - Journey","doc":"To illustrate a few concepts (graph, dependencies â€“ including conditional dependencies, computation functions, persistence), here is a simple example.\n\nThis graph adds two numbers when they become available, and conditionally sets the \"too large\" flag.\n\n\n```elixir\niex> import Journey.Node\niex> # Defining a graph, with two input nodes and two downstream computations.\niex> graph = Journey.new_graph(\n...>   \"demo graph\",\n...>   \"v1\",\n...>   [\n...>     input(:x),\n...>     input(:y),\n...>     # :sum is unblocked when :x and :y are provided.\n...>     compute(:sum, [:x, :y], fn %{x: x, y: y} -> {:ok, x + y} end),\n...>     # :large_value_alert is unblocked when :sum is provided and is greater than 40.\n...>     compute(\n...>         :large_value_alert,\n...>         [sum: fn sum_node -> sum_node.node_value > 40 end],\n...>         fn %{sum: sum} -> {:ok, \"ðŸš¨, at #{sum}\"} end,\n...>         f_on_save: fn _execution_id, _result ->\n...>            # (e.g. send a pubsub notification to the LiveView process to update the UI)\n...>            :ok\n...>         end\n...>     )\n...>   ]\n...> )\niex> # Start an execution of this graph, set input values, read computed values.\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :x, 12)\niex> execution = Journey.set_value(execution, :y, 2)\niex> Journey.get_value(execution, :sum, wait_any: true)\n{:ok, 14}\niex> Journey.get_value(execution, :large_value_alert)\n{:error, :not_set}\niex> eid = execution.id\niex> # After an outage / redeployment / page reload / long pause, an execution\niex> # can be reloaded and continue, as if nothing happened.\niex> execution = Journey.load(eid)\niex> # An update to :y triggers a re-computation of downstream values.\niex> execution = Journey.set_value(execution, :y, 37)\niex> Journey.get_value(execution, :large_value_alert, wait_any: true)\n{:ok, \"ðŸš¨, at 49\"}\niex> Journey.values(execution) |> redact([:execution_id, :last_updated_at])\n%{execution_id: \"...\", last_updated_at: 1234567890, sum: 49, x: 12, y: 37, large_value_alert: \"ðŸš¨, at 49\"}\n```\n\nThe graph can be visualized as a Mermaid graph:\n\n```\n> Journey.Tools.generate_mermaid_graph(graph)\ngraph TD\n  %% Graph\n  subgraph Graph[\"ðŸ§© 'demo graph', version v1\"]\n      execution_id[execution_id]\n      last_updated_at[last_updated_at]\n      x[x]\n      y[y]\n      sum[\"sum (anonymous fn)\"]\n      large_value_alert[\"large_value_alert (anonymous fn)\"]\n\n      x -->  sum\n      y -->  sum\n      sum -->  large_value_alert\n  end\n\n  %% Styling\n  classDef inputNode fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000000\n  classDef computeNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000000\n  classDef scheduleNode fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000000\n  classDef mutateNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000000\n\n  %% Apply styles to actual nodes\n  class y,x,last_updated_at,execution_id inputNode\n  class large_value_alert,sum computeNode\n```\n\nA few things to note about this example:\n* Every input value (`:x`, `:y`), or computation result (`:sum`, `:large_value_alert`) is persisted as soon as it becomes available,\n* The functions attached to `:sum` and `:large_value_alert`\n  - are called reliably, with a retry policy,\n  - will execute on any of the replicas of your application,\n  - are called proactively â€“Â when their upstream dependencies are available.\n* Executions of this flow can take as long as needed (milliseconds? months?), and will live through system restarts, crashes, redeployments, page reloads, etc.","ref":"Journey.html#module-overview"},{"type":"module","title":"So What Exactly Does Journey Provide? - Journey","doc":"Despite the simplicity of use, here are a few things provided by Journey that are worth noting:\n\n* Persistence: Executions are persisted, so if the customer leaves the web site, or if the system crashes, their execution can be reloaded and continued from where it left off.\n\n* Scaling: Since Journey runs as part of your application, it scales with your application. Your graph's computations (`:sum`'s function in the example above, or `&compute_zodiac_sign/1` and `&compute_horoscope/1` in the example above) run on the same nodes where the replicas of your application are running. No additional infrastructure or cloud services are needed.\n\n* Reliability: Journey uses database-based supervision of computation tasks: The `compute` functions are subject to customizable retry policy, so if `:sum`'s function above or `&compute_horoscope/1` below fails because of a temporary glitch (e.g. the LLM service it uses for drafting horoscopes is currently overloaded), it will be retried.\n\n* Code Structure: The flow of your application is captured in the Journey graph, and the business logic is captured in the compute functions (`:sum`'s function above, or `&compute_zodiac_sign/1` and `&compute_horoscope/1` below). This clean separation supports you in structuring the functionality of your application in a clear, easy to understand and maintain way.\n\n* Conditional flow: Journey allows you to define conditions for when a node is to be unblocked. So if your graph includes a \"credit_approval_decision\" node, the decision can inform which part of the graph is to be executed next (sending a \"congrats!\" email and starting the credit card issuance process, or sending a \"sad trombone\" email).\n\n* Graph Visualization: Journey provides tools for visualizing your application's graph, so you can easily see the flow of data and computations in your application, and to share and discuss it with your team.\n\n* Scheduling: Your graph can include computations that are scheduled to run at a later time, or on a recurring basis. Daily horoscope emails! A reminder email if they haven't visited the web site in a while! A \"happy birthday\" email!\n\n* Removing PII. Journey gives you an easy way to erase sensitive data once it is no longer needed. For example, your Credit Card Application graph can include a step to remove the SSN once the credit score has been computed. For an example, please see\n```\n  mutate(:ssn_redacted, [:credit_score], fn _ -> {:ok, \" \"} end, mutates: :ssn)\n```\nnode in the example credit card application graph, [here](https://github.com/markmark206/journey/blob/063342e616267375a0fa042317d5984d1198cb5c/lib/journey/examples/credit_card_application.ex#L210), which mutates the contents of the :ssn node, replacing its value with \" \", when :credit_score completes.\n\n* Tooling and visualization: `Journey.Tools` provides a set of tools for introspecting and managing executions, and for visualizing your application's graph.","ref":"Journey.html#module-so-what-exactly-does-journey-provide"},{"type":"module","title":"A (slightly) richer example: computing horoscopes - Journey","doc":"Consider a simple Horoscope application that computes a customer's zodiac sign and horoscope based on their birthday. The application will ask the customer to `input` their name and birthday, and it then auto-`compute`s their zodiac sign and horoscope.\n\nThis application can be thought of as a graph of nodes, where each node represents a piece of customer-provided data or the result of a computation. Add functions for computing the zodiac sign and horoscope, and capture the sequencing of the computations, and you have a graph that captures the flow of data and computations in your application. When a customer visits your application, you can start the execution of the graph, to accept and store customer-provided inputs (name, birthday), and to compute the zodiac sign and horoscope based on these inputs.\n\nJourney provides a way to define such graphs, and to run their executions, to serve your customer flows.","ref":"Journey.html#module-a-slightly-richer-example-computing-horoscopes"},{"type":"module","title":"Step-by-Step - Journey","doc":"Below is a step-by-step example of defining a Journey graph for this Horoscope application.\n\n(These are code snippets, if you want a complete fragment you can paste into `iex` or livebook, scroll down to the \"Putting together\" code block.)\n\nThis graph captures customer `input`s, and defines `compute`ations (together with their functions and prerequisites):\n\n```elixir\ngraph = Journey.new_graph(\n  \"horoscope workflow - module doctest\",\n  \"v1.0.0\",\n  [\n    input(:first_name),\n    input(:birth_day),\n    input(:birth_month),\n    compute(\n      :zodiac_sign,\n      [:birth_month, :birth_day],\n      &compute_zodiac_sign/1\n    ),\n    compute(\n      :horoscope,\n      [:first_name, :zodiac_sign],\n      &compute_horoscope/1\n    )\n  ]\n)\n```\n\nWhen a customer lands on your web page, and starts a new flow, your application will start a new execution of the graph,\n\n```elixir\nexecution = Journey.start_execution(graph)\n```\n\nand it will populate the execution with the input values (name, birthday) as the customer provides them:\n\n```elixir\nexecution = Journey.set_value(execution, :first_name, \"Mario\")\nexecution = Journey.set_value(execution, :birth_day, 5)\nexecution = Journey.set_value(execution, :birth_month, \"May\")\n```\n\nProviding these input values will trigger automatic computations of the customer's zodiac_sign and the horoscope, which can then be read from the execution and rendered on the web page.\n\n```\n{:ok, zodiac_sign} = Journey.get_value(execution, :zodiac_sign, wait_any: true)\n{:ok, horoscope} = Journey.get_value(execution, :horoscope, wait_any: true)\n```\n\nAnd that's it!","ref":"Journey.html#module-step-by-step"},{"type":"module","title":"Example - Journey","doc":"Putting together the components of the horoscope example into a complete, running doctest example:\n\n\n```elixir\niex> # 1. Define a graph capturing the data and the logic of the application -\niex> #    the nodes, their dependencies, and their computations:\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"horoscope workflow - module doctest\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:first_name),\n...>         input(:birth_day),\n...>         input(:birth_month),\n...>         compute(\n...>           :zodiac_sign,\n...>           # Depends on user-supplied data:\n...>           [:birth_month, :birth_day],\n...>           # Computes itself, once the dependencies are satisfied:\n...>           fn %{birth_month: _birth_month, birth_day: _birth_day} ->\n...>             {:ok, \"Taurus\"}\n...>           end\n...>         ),\n...>         compute(\n...>           :horoscope,\n...>           # Computes itself once :first_name and :zodiac_sign are in place:\n...>           [:first_name, :zodiac_sign],\n...>           fn %{first_name: name, zodiac_sign: zodiac_sign} ->\n...>             {:ok, \"ðŸªs await, #{zodiac_sign} #{name}!\"}\n...>           end\n...>         )\n...>       ]\n...>     )\niex>\niex> # 2. For every customer visiting your website, start a new execution of the graph:\niex> e = Journey.start_execution(graph)\niex>\niex> # 3. Populate the execution's nodes with the data as provided by the visitor:\niex> e = Journey.set_value(e, :birth_day, 26)\niex>\niex> # As a side note: if the user leaves and comes back later or if everything crashes,\niex> # you can always reload the execution using its id:\niex> e = Journey.load(e.id)\niex>\niex> # Continuing, as if nothing happened:\niex> e = Journey.set_value(e, :birth_month, \"April\")\niex>\niex> # 4. Now that we have :birth_month and :birth_day, :zodiac_sign will compute itself:\niex> Journey.get_value(e, :zodiac_sign, wait_any: true)\n{:ok, \"Taurus\"}\niex> Journey.values(e) |> redact([:execution_id, :last_updated_at])\n%{birth_day: 26, birth_month: \"April\", zodiac_sign: \"Taurus\", execution_id: \"...\", last_updated_at: 1234567890}\niex>\niex> # 5. Once we get :first_name, the :horoscope node will compute itself:\niex> e = Journey.set_value(e, :first_name, \"Mario\")\niex> Journey.get_value(e, :horoscope, wait_any: true)\n{:ok, \"ðŸªs await, Taurus Mario!\"}\niex>\niex> Journey.values(e) |> redact([:execution_id, :last_updated_at])\n%{birth_day: 26, birth_month: \"April\", first_name: \"Mario\", horoscope: \"ðŸªs await, Taurus Mario!\", zodiac_sign: \"Taurus\", execution_id: \"...\", last_updated_at: 1234567890}\niex>\niex> # 6. and we can always list executions.\niex> this_execution = Journey.list_executions(graph_name: \"horoscope workflow - module doctest\", order_by_execution_fields: [:inserted_at]) |> Enum.reverse() |> hd\niex> e.id == this_execution.id\ntrue\n```\n\nFor a more in-depth example of building a more complex application, see the Credit Card Application example in `Journey.Examples.CreditCardApplication`.","ref":"Journey.html#module-example"},{"type":"function","title":"Journey.archive/1","doc":"Archives an execution, making it invisible and stopping all background processing.\n\nArchiving permanently (*) freezes an execution by marking it with an archived timestamp.\nThis removes it from normal visibility and excludes it from all scheduler processing,\nwhile preserving the data for potential future access.\n\n*) an execution can be unarchived by calling `unarchive/1`","ref":"Journey.html#archive/1"},{"type":"function","title":"Quick Example - Journey.archive/1","doc":"```elixir\narchived_at = Journey.archive(execution)\nJourney.load(execution)  # Returns nil (hidden)\nJourney.load(execution, include_archived: true)  # Can still access\n```\n\nUse `unarchive/1` to reverse archiving and `list_executions/1` with `:include_archived` to find archived executions.","ref":"Journey.html#archive/1-quick-example"},{"type":"function","title":"Parameters - Journey.archive/1","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct or execution ID string","ref":"Journey.html#archive/1-parameters"},{"type":"function","title":"Returns - Journey.archive/1","doc":"* Integer timestamp (Unix epoch seconds) when the execution was archived","ref":"Journey.html#archive/1-returns"},{"type":"function","title":"Key Behaviors - Journey.archive/1","doc":"* **Scheduler exclusion** - Archived executions are excluded from all background sweeps and processing\n* **Hidden by default** - Not returned by `list_executions/1` or `load/2` unless explicitly included\n* **Idempotent** - Archiving an already archived execution returns the existing timestamp\n* **Reversible** - Use `unarchive/1` to restore normal visibility and processing","ref":"Journey.html#archive/1-key-behaviors"},{"type":"function","title":"Examples - Journey.archive/1","doc":"Basic archiving workflow:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\"archive example\", \"v1.0.0\", [input(:data)])\niex> execution = Journey.start_execution(graph)\niex> execution.archived_at\nnil\niex> archived_at = Journey.archive(execution)\niex> is_integer(archived_at)\ntrue\niex> Journey.load(execution)\nnil\niex> Journey.load(execution, include_archived: true) != nil\ntrue\n```\n\nIdempotent behavior:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\"archive idempotent\", \"v1.0.0\", [input(:data)])\niex> execution = Journey.start_execution(graph)\niex> first_archive = Journey.archive(execution)\niex> second_archive = Journey.archive(execution)\niex> first_archive == second_archive\ntrue\n```","ref":"Journey.html#archive/1-examples"},{"type":"function","title":"Journey.get_value/3","doc":"Returns the value of a node in an execution. Optionally waits for the value to be set.","ref":"Journey.html#get_value/3"},{"type":"function","title":"Quick Examples - Journey.get_value/3","doc":"```elixir\n# Basic usage - get a set value\n{:ok, value} = Journey.get_value(execution, :name)\n\n# Wait for a computed value to be available\n{:ok, result} = Journey.get_value(execution, :computed_field, wait_any: true)\n\n# Wait for a new version of the value\n{:ok, new_value} = Journey.get_value(execution, :name, wait_new: true)\n```\n\nUse `set_value/3` to set input values that trigger computations.","ref":"Journey.html#get_value/3-quick-examples"},{"type":"function","title":"Parameters - Journey.get_value/3","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct\n* `node_name` - Atom representing the node name (must exist in the graph)\n* `opts` - Keyword list of options (see Options section below)","ref":"Journey.html#get_value/3-parameters"},{"type":"function","title":"Returns - Journey.get_value/3","doc":"* `{:ok, value}` â€“ the value is set\n* `{:error, :not_set}` â€“ the value is not yet set\n* `{:error, :no_such_value}` â€“ the node does not exist","ref":"Journey.html#get_value/3-returns"},{"type":"function","title":"Errors - Journey.get_value/3","doc":"* Raises `RuntimeError` if the node name does not exist in the execution's graph\n* Raises `ArgumentError` if both `:wait_any` and `:wait_new` options are provided (mutually exclusive)","ref":"Journey.html#get_value/3-errors"},{"type":"function","title":"Options - Journey.get_value/3","doc":"* `:wait_any` â€“Â whether or not to wait for the value to be set. This option can have the following values:\n  * `false` or `0` â€“ return immediately without waiting (default)\n  * `true` â€“ wait until the value is available, or until timeout\n  * a positive integer â€“ wait for the supplied number of milliseconds (default: 30_000)\n  * `:infinity` â€“ wait indefinitely\n  This is useful for self-computing nodes, where the value is computed asynchronously.\n* `:wait_new` â€“ whether to wait for a new revision of the value, compared to the version in the supplied execution. This option can have the following values:\n  * `false` â€“ do not wait for a new revision (default)\n  * `true` â€“ wait for a value with a higher revision than the current one, or the first value if none exists yet, or until timeout\n  * a positive integer â€“ wait for the supplied number of milliseconds for a new revision\n  This is useful for when want a new version of the value, and are waiting for it to get computed.\n\n**Note:** `:wait_any` and `:wait_new` are mutually exclusive.","ref":"Journey.html#get_value/3-options"},{"type":"function","title":"Examples - Journey.get_value/3","doc":"```elixir\n  iex> execution =\n  ...>    Journey.Examples.Horoscope.graph() |>\n  ...>    Journey.start_execution() |>\n  ...>    Journey.set_value(:birth_day, 26)\n  iex> Journey.get_value(execution, :birth_day)\n  {:ok, 26}\n  iex> Journey.get_value(execution, :birth_month)\n  {:error, :not_set}\n  iex> Journey.get_value(execution, :astrological_sign)\n  {:error, :not_set}\n  iex> execution = Journey.set_value(execution, :birth_month, \"April\")\n  iex> Journey.get_value(execution, :astrological_sign)\n  {:error, :not_set}\n  iex> Journey.get_value(execution, :astrological_sign, wait_any: true)\n  {:ok, \"Taurus\"}\n  iex> Journey.get_value(execution, :horoscope, wait_any: 2_000)\n  {:error, :not_set}\n  iex> execution = Journey.set_value(execution, :first_name, \"Mario\")\n  iex> Journey.get_value(execution, :horoscope, wait_any: true)\n  {:ok, \"ðŸªs await, Taurus Mario!\"}\n  ```","ref":"Journey.html#get_value/3-examples"},{"type":"function","title":"Journey.history/1","doc":"Returns the chronological history of all successful computations and set values for an execution.\n\nThis function provides visibility into the order of operations during execution, showing both\nvalue sets and successful computations in chronological order. Only successful computations\nare included; failed computations are filtered out. At the same revision, computations appear\nbefore values.","ref":"Journey.html#history/1"},{"type":"function","title":"Quick Example - Journey.history/1","doc":"```elixir\nhistory = Journey.history(execution)\n# [%{node_name: :x, computation_or_value: :value, revision: 1},\n#  %{node_name: :sum, computation_or_value: :computation, revision: 2}, ...]\n```\n\nUse `values/2` to see only current values, or `set_value/3` and `get_value/3` for individual operations.","ref":"Journey.html#history/1-quick-example"},{"type":"function","title":"Parameters - Journey.history/1","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct or execution ID string","ref":"Journey.html#history/1-parameters"},{"type":"function","title":"Returns - Journey.history/1","doc":"* List of maps sorted by revision, where each map contains:\n  * `:computation_or_value` - either `:computation` or `:value`\n  * `:node_name` - the name of the node\n  * `:node_type` - the type of the node (`:input`, `:compute`, `:mutate`, etc.)\n  * `:revision` - the execution revision when this operation completed\n  * `:value` - the actual value (only present for `:value` entries)","ref":"Journey.html#history/1-returns"},{"type":"function","title":"Examples - Journey.history/1","doc":"Basic usage showing value sets and computation:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\"history example\", \"v1.0.0\", [\n...>   input(:x),\n...>   input(:y),\n...>   compute(:sum, [:x, :y], fn %{x: x, y: y} -> {:ok, x + y} end)\n...> ])\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :x, 10)\niex> execution = Journey.set_value(execution, :y, 20)\niex> Journey.get_value(execution, :sum, wait_any: true)\n{:ok, 30}\niex> Journey.history(execution) |> Enum.map(fn entry ->\n...>   case entry.node_name do\n...>     :execution_id -> %{entry | value: \"...\"}\n...>     :last_updated_at -> %{entry | value: 1234567890}\n...>     _ -> entry\n...>   end\n...> end)\n[\n  %{node_name: :execution_id, node_type: :input, computation_or_value: :value, value: \"...\", revision: 0},\n  %{node_name: :x, node_type: :input, computation_or_value: :value, value: 10, revision: 1},\n  %{node_name: :y, node_type: :input, computation_or_value: :value, value: 20, revision: 2},\n  %{node_name: :sum, node_type: :compute, computation_or_value: :computation, revision: 4},\n  %{node_name: :last_updated_at, node_type: :input, computation_or_value: :value, value: 1234567890, revision: 4},\n  %{node_name: :sum, node_type: :compute, computation_or_value: :value, value: 30, revision: 4}\n]\n```","ref":"Journey.html#history/1-examples"},{"type":"function","title":"Journey.list_executions/1","doc":"Queries and retrieves multiple executions from the database with flexible filtering, sorting, and pagination.\n\nThis function enables searching across all executions in your system, with powerful filtering\ncapabilities based on graph names, node values, and execution metadata. It's essential for\nmonitoring workflows, building dashboards, and analyzing execution patterns.","ref":"Journey.html#list_executions/1"},{"type":"function","title":"Quick Example - Journey.list_executions/1","doc":"```elixir\n# List all executions for a specific graph\nexecutions = Journey.list_executions(graph_name: \"user_onboarding\")\n\n# List executions for a specific graph version\nv1_executions = Journey.list_executions(\n  graph_name: \"user_onboarding\",\n  graph_version: \"v1.0.0\"\n)\n\n# Find executions where age > 18\nadults = Journey.list_executions(\n  graph_name: \"user_registration\",\n  filter_by: [{:age, :gt, 18}]\n)\n```\n\nUse with `start_execution/1` to create executions and `load/2` to get individual execution details.","ref":"Journey.html#list_executions/1-quick-example"},{"type":"function","title":"Parameters - Journey.list_executions/1","doc":"* `options` - Keyword list of query options (all optional):\n  * `:graph_name` - String name of a specific graph to filter by\n  * `:graph_version` - String version of a specific graph to filter by (requires :graph_name)\n  * `:sort_by` - List of fields to sort by, including both execution fields and node values (see Sorting section for details)\n  * `:filter_by` - List of node value filters using database-level filtering for optimal performance. Each filter is a tuple `{node_name, operator, value}` or `{node_name, operator}` for nil checks. Operators: `:eq`, `:neq`, `:lt`, `:lte`, `:gt`, `:gte` (comparisons), `:in`, `:not_in` (membership), `:is_nil`, `:is_not_nil` (existence). Values can be strings, numbers, booleans, nil or lists (used with `:in` and `:not_in`). Complex values (maps, tuples, functions) will raise an ArgumentError.\n  * `:limit` - Maximum number of results (default: 10,000)\n  * `:offset` - Number of results to skip for pagination (default: 0)\n  * `:include_archived` - Whether to include archived executions (default: false)","ref":"Journey.html#list_executions/1-parameters"},{"type":"function","title":"Returns - Journey.list_executions/1","doc":"* List of `%Journey.Persistence.Schema.Execution{}` structs with preloaded values and computations\n* Empty list `[]` if no executions match the criteria","ref":"Journey.html#list_executions/1-returns"},{"type":"function","title":"Options - Journey.list_executions/1","doc":"### `:sort_by`\nSort by execution fields or node values. Supports atoms for ascending (`[:updated_at]`),\nkeywords for direction (`[updated_at: :desc]`), and mixed formats (`[:graph_name, inserted_at: :desc]`).\n\n**Available fields:**\n* Execution fields: `:inserted_at`, `:updated_at`, `:revision`, `:graph_name`, `:graph_version`\n* Node values: Any node name from the graph (e.g., `:age`, `:score`) using JSONB ordering\n* Direction: `:asc` (default) or `:desc`","ref":"Journey.html#list_executions/1-options"},{"type":"function","title":"Key Behaviors - Journey.list_executions/1","doc":"* Filtering performed at database level for optimal performance\n* Only primitive values supported for filtering (complex types raise errors)\n* Archived executions excluded by default","ref":"Journey.html#list_executions/1-key-behaviors"},{"type":"function","title":"Examples - Journey.list_executions/1","doc":"Basic listing by graph name:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"list example basic - #{Journey.Helpers.Random.random_string()}\",\n...>   \"v1.0.0\",\n...>   [input(:status)]\n...> )\niex> Journey.start_execution(graph) |> Journey.set_value(:status, \"active\")\niex> Journey.start_execution(graph) |> Journey.set_value(:status, \"pending\")\niex> executions = Journey.list_executions(graph_name: graph.name)\niex> length(executions)\n2\n```\n\nFiltering by graph version:\n\n```elixir\niex> import Journey.Node\niex> graph_name = \"version example yyJE45MjaDdx\"\niex> graph_v1 = Journey.new_graph(\n...>   graph_name,\n...>   \"v1.0.0\",\n...>   [input(:data)]\n...> )\niex> graph_v2 = Journey.new_graph(\n...>   graph_name,\n...>   \"v2.0.0\",\n...>   [input(:data), input(:new_field)]\n...> )\niex> Journey.start_execution(graph_v1) |> Journey.set_value(:data, \"v1 data\")\niex> Journey.start_execution(graph_v2) |> Journey.set_value(:data, \"v2 data\")\niex> Journey.list_executions(graph_name: graph_v1.name, graph_version: \"v1.0.0\") |> length()\n1\niex> Journey.list_executions(graph_name: graph_v1.name, graph_version: \"v2.0.0\") |> length()\n1\niex> Journey.list_executions(graph_name: graph_v1.name) |> length()\n2\n```\n\nValidation that graph_version requires graph_name:\n\n```elixir\niex> Journey.list_executions(graph_version: \"v1.0.0\")\n** (ArgumentError) Option :graph_version requires :graph_name to be specified\n```\n\nSorting by execution fields and node values:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"sort example - #{Journey.Helpers.Random.random_string()}\",\n...>   \"v1.0.0\",\n...>   [input(:priority)]\n...> )\niex> Journey.start_execution(graph) |> Journey.set_value(:priority, \"high\")\niex> Journey.start_execution(graph) |> Journey.set_value(:priority, \"low\")\niex> Journey.start_execution(graph) |> Journey.set_value(:priority, \"medium\")\niex> # Sort by priority descending - shows the actual sorted values\niex> Journey.list_executions(graph_name: graph.name, sort_by: [priority: :desc]) |> Enum.map(fn e -> Journey.values(e) |> Map.get(:priority) end)\n[\"medium\", \"low\", \"high\"]\n```\n\nFiltering with multiple operators:\n\n```elixir\niex> graph = Journey.Examples.Horoscope.graph()\niex> for day <- 1..20, do: Journey.start_execution(graph) |> Journey.set_value(:birth_day, day) |> Journey.set_value(:birth_month, 4) |> Journey.set_value(:first_name, \"Mario\")\niex> # Various filtering examples\niex> Journey.list_executions(graph_name: graph.name, filter_by: [{:birth_day, :eq, 10}]) |> Enum.count()\n1\niex> Journey.list_executions(graph_name: graph.name, filter_by: [{:birth_day, :neq, 10}]) |> Enum.count()\n19\niex> Journey.list_executions(graph_name: graph.name, filter_by: [{:birth_day, :lte, 5}]) |> Enum.count()\n5\niex> Journey.list_executions(graph_name: graph.name, filter_by: [{:birth_day, :in, [5, 10, 15]}]) |> Enum.count()\n3\niex> Journey.list_executions(graph_name: graph.name, filter_by: [{:first_name, :is_not_nil}]) |> Enum.count()\n20\n```\n\nMultiple filters, sorting, and pagination:\n\n```elixir\niex> graph = Journey.Examples.Horoscope.graph()\niex> for day <- 1..20, do: Journey.start_execution(graph) |> Journey.set_value(:birth_day, day) |> Journey.set_value(:birth_month, 4) |> Journey.set_value(:first_name, \"Mario\")\niex> # Multiple filters combined\niex> Journey.list_executions(\n...>   graph_name: graph.name,\n...>   filter_by: [{:birth_day, :gt, 10}, {:first_name, :is_not_nil}],\n...>   sort_by: [birth_day: :desc],\n...>   limit: 5\n...> ) |> Enum.count()\n5\niex> # Pagination\niex> Journey.list_executions(graph_name: graph.name, limit: 3) |> Enum.count()\n3\niex> Journey.list_executions(graph_name: graph.name, limit: 5, offset: 10) |> Enum.count()\n5\n```\n\nIncluding archived executions:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"list example - archived - #{Journey.Helpers.Random.random_string()}\",\n...>   \"v1.0.0\",\n...>   [input(:status)]\n...> )\niex> e1 = Journey.start_execution(graph)\niex> _e2 = Journey.start_execution(graph)\niex> Journey.archive(e1)\niex> Journey.list_executions(graph_name: graph.name) |> length()\n1\niex> Journey.list_executions(graph_name: graph.name, include_archived: true) |> length()\n2\n```","ref":"Journey.html#list_executions/1-examples"},{"type":"function","title":"Journey.load/2","doc":"Reloads the current state of an execution from the database to get the latest changes.\n\nExecutions can be modified by their background computations, or scheduled events, or other processes setting their values. This function is used to get the latest state of an execution -- as part of normal operations, or when the system starts up, or when the user whose session is being tracked as an execution comes back to the web site and resumes their flow.","ref":"Journey.html#load/2"},{"type":"function","title":"Quick Example - Journey.load/2","doc":"```elixir\nexecution = Journey.set_value(execution, :name, \"Mario\")\nexecution = Journey.load(execution)  # Get updated state with new revision\n{:ok, greeting} = Journey.get_value(execution, :greeting, wait_any: true)\n```\n\nUse `set_value/3` and `get_value/3` to modify and read execution values.","ref":"Journey.html#load/2-quick-example"},{"type":"function","title":"Parameters - Journey.load/2","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct or execution ID string\n* `opts` - Keyword list of options (see Options section below)","ref":"Journey.html#load/2-parameters"},{"type":"function","title":"Returns - Journey.load/2","doc":"* A `%Journey.Persistence.Schema.Execution{}` struct with current database state, or `nil` if not found","ref":"Journey.html#load/2-returns"},{"type":"function","title":"Options - Journey.load/2","doc":"* `:preload` - Whether to preload associated nodes and values. Defaults to `true`.\n  Set to `false` for better performance when you only need execution metadata.\n* `:include_archived` - Whether to include archived executions. Defaults to `false`.\n  Archived executions are normally hidden but can be loaded with this option.","ref":"Journey.html#load/2-options"},{"type":"function","title":"Key Behaviors - Journey.load/2","doc":"* **Fresh state** - Always returns the current state from the database, not cached data\n* **Revision tracking** - Loaded execution will have the latest revision number\n* **Archived handling** - Archived executions return `nil` unless explicitly included\n* **Performance option** - Use `preload: false` to skip loading values/computations for speed","ref":"Journey.html#load/2-key-behaviors"},{"type":"function","title":"Examples - Journey.load/2","doc":"Basic reloading after value changes:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"load example - basic\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         compute(:greeting, [:name], fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end)\n...>       ]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> execution.revision\n0\niex> execution = Journey.set_value(execution, :name, \"Alice\")\niex> execution.revision > 0\ntrue\niex> {:ok, \"Hello, Alice!\"} = Journey.get_value(execution, :greeting, wait_any: true)\niex> reloaded = Journey.load(execution)\niex> reloaded.revision >= execution.revision\ntrue\n```\n\nLoading by execution ID:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"load example - by id\",\n...>       \"v1.0.0\",\n...>       [input(:data)]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> execution_id = execution.id\niex> reloaded = Journey.load(execution_id)\niex> reloaded.id == execution_id\ntrue\n```\n\nPerformance optimization with preload option:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"load example - no preload\",\n...>       \"v1.0.0\",\n...>       [input(:data)]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> fast_load = Journey.load(execution, preload: false)\niex> fast_load.id == execution.id\ntrue\n```\n\nHandling archived executions:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"load example - archived\",\n...>       \"v1.0.0\",\n...>       [input(:data)]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> Journey.archive(execution)\niex> Journey.load(execution)\nnil\niex> Journey.load(execution, include_archived: true) != nil\ntrue\n```","ref":"Journey.html#load/2-examples"},{"type":"function","title":"Journey.new_graph/4","doc":"Creates a new computation graph with the given name, version, and node definitions.\n\nThis is the foundational function for defining Journey graphs. It creates a validated\ngraph structure that can be used to start executions with `start_execution/1`. The graph\ndefines the data flow, dependencies, and computations for your application workflow.","ref":"Journey.html#new_graph/4"},{"type":"function","title":"Quick Example - Journey.new_graph/4","doc":"```elixir\nimport Journey.Node\ngraph = Journey.new_graph(\n  \"user onboarding\",\n  \"v1.0.0\",\n  [\n    input(:email),\n    compute(:welcome_message, [:email], fn %{email: email} ->\n      {:ok, \"Welcome #{email}!\"}\n    end)\n  ]\n)\nexecution = Journey.start_execution(graph)\n```\n\nUse `start_execution/1` to create executions and `set_value/3` to populate input values.","ref":"Journey.html#new_graph/4-quick-example"},{"type":"function","title":"Parameters - Journey.new_graph/4","doc":"* `name` - String identifying the graph (e.g., \"user registration workflow\")\n* `version` - String version identifier following semantic versioning (e.g., \"v1.0.0\")\n* `nodes` - List of node definitions created with `Journey.Node` functions (`input/1`, `compute/4`, etc.)\n* `opts` - Optional keyword list of options:\n  * `:f_on_save` - Graph-wide callback function invoked after any node computation succeeds.\n    Receives `(execution_id, node_name, result)` where result is `{:ok, value}` or `{:error, reason}`.\n    This callback is called after any node-specific `f_on_save` callbacks.","ref":"Journey.html#new_graph/4-parameters"},{"type":"function","title":"Returns - Journey.new_graph/4","doc":"* `%Journey.Graph{}` struct representing the validated and registered computation graph","ref":"Journey.html#new_graph/4-returns"},{"type":"function","title":"Errors - Journey.new_graph/4","doc":"* Raises `RuntimeError` if graph validation fails (e.g., circular dependencies, unknown node references)\n* Raises `ArgumentError` if parameters have invalid types or empty node list\n* Raises `KeywordValidator.Error` if options are invalid","ref":"Journey.html#new_graph/4-errors"},{"type":"function","title":"Key Behaviors - Journey.new_graph/4","doc":"* **Validation** - Automatically validates graph structure for cycles, dependency correctness\n* **Registration** - Registers graph in catalog for execution tracking and reloading\n* **Immutable** - Graph definition is immutable once created; create new versions for changes\n* **Node types** - Supports input, compute, mutate, schedule_once, and schedule_recurring nodes\n* **`f_on_save` Callbacks** - If defined, the graph-wide `f_on_save` callback is called after Node-specific `f_on_save`s (if defined)","ref":"Journey.html#new_graph/4-key-behaviors"},{"type":"function","title":"Examples - Journey.new_graph/4","doc":"Basic workflow with input and computation:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"greeting workflow\",\n...>   \"v1.0.0\",\n...>   [\n...>     input(:name),\n...>     compute(:greeting, [:name], fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end)\n...>   ]\n...> )\niex> graph.name\n\"greeting workflow\"\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :name, \"Alice\")\niex> Journey.get_value(execution, :greeting, wait_any: true)\n{:ok, \"Hello, Alice!\"}\n```\n\nGraph with a graph-wide `f_on_save` callback:\n\n```elixir\niex> import Journey.Node\niex> _graph = Journey.new_graph(\n...>   \"notification workflow\",\n...>   \"v1.0.0\",\n...>   [\n...>     input(:user_id),\n...>     compute(:fetch_user, [:user_id], fn %{user_id: id} ->\n...>       {:ok, %{id: id, name: \"User #{id}\"}}\n...>     end),\n...>     compute(:send_email, [:fetch_user], fn %{fetch_user: user} ->\n...>       {:ok, \"Email sent to #{user.name}\"}\n...>     end)\n...>   ],\n...>   f_on_save: fn _execution_id, node_name, result ->\n...>     # This will be called for both :fetch_user and :send_email computations\n...>     IO.puts(\"Node #{node_name} completed with result: #{inspect(result)}\")\n...>     :ok\n...>   end\n...> )\n```\n\nComplex workflow with conditional dependencies:\n\n```elixir\niex> import Journey.Node\niex> import Journey.Node.Conditions\niex> import Journey.Node.UpstreamDependencies\niex> graph = Journey.new_graph(\n...>       \"horoscope workflow\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:first_name),\n...>         input(:birth_day),\n...>         input(:birth_month),\n...>         compute(\n...>           :zodiac_sign,\n...>           [:birth_month, :birth_day],\n...>           fn %{birth_month: _birth_month, birth_day: _birth_day} ->\n...>             {:ok, \"Taurus\"}\n...>           end\n...>         ),\n...>         compute(\n...>           :horoscope,\n...>           unblocked_when({\n...>             :and,\n...>             [\n...>               {:first_name, &provided?/1},\n...>               {:zodiac_sign, &provided?/1}\n...>             ]\n...>           }),\n...>           fn %{first_name: name, zodiac_sign: zodiac_sign} ->\n...>             {:ok, \"ðŸªs await, #{zodiac_sign} #{name}!\"}\n...>           end\n...>         )\n...>       ]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :birth_day, 15)\niex> execution = Journey.set_value(execution, :birth_month, \"May\")\niex> Journey.get_value(execution, :zodiac_sign, wait_any: true)\n{:ok, \"Taurus\"}\niex> execution = Journey.set_value(execution, :first_name, \"Bob\")\niex> Journey.get_value(execution, :horoscope, wait_any: true)\n{:ok, \"ðŸªs await, Taurus Bob!\"}\n```\n\nMultiple node types in a workflow:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"data processing workflow\",\n...>   \"v2.1.0\",\n...>   [\n...>     input(:raw_data),\n...>     compute(:upper_case, [:raw_data], fn %{raw_data: data} ->\n...>       {:ok, String.upcase(data)}\n...>     end),\n...>     compute(:suffix, [:upper_case], fn %{upper_case: data} ->\n...>       {:ok, \"#{data} omg yay\"}\n...>     end)\n...>   ]\n...> )\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :raw_data, \"hello world\")\niex> Journey.get_value(execution, :upper_case, wait_any: true)\n{:ok, \"HELLO WORLD\"}\niex> Journey.get_value(execution, :suffix, wait_any: true)\n{:ok, \"HELLO WORLD omg yay\"}\n```","ref":"Journey.html#new_graph/4-examples"},{"type":"function","title":"Journey.set_value/3","doc":"Sets the value for an input node in an execution and triggers recomputation of dependent nodes.\n\nWhen a value is set, Journey automatically recomputes any dependent computed nodes to ensure\nconsistency across the dependency graph. The operation is idempotent - setting the same value\ntwice has no effect.","ref":"Journey.html#set_value/3"},{"type":"function","title":"Parameters - Journey.set_value/3","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct or execution ID string\n* `node_name` - Atom representing the input node name (must exist in the graph)\n* `value` - The value to set. Supported types: nil, string, number, map, list, boolean. Note that if the map or the list contains atoms, those atoms will be converted to strings.","ref":"Journey.html#set_value/3-parameters"},{"type":"function","title":"Returns - Journey.set_value/3","doc":"* Updated `%Journey.Persistence.Schema.Execution{}` struct with incremented revision (if value changed)","ref":"Journey.html#set_value/3-returns"},{"type":"function","title":"Errors - Journey.set_value/3","doc":"* Raises `RuntimeError` if the node name does not exist in the execution's graph\n* Raises `RuntimeError` if attempting to set a compute node (only input nodes can be set)","ref":"Journey.html#set_value/3-errors"},{"type":"function","title":"Key Behaviors - Journey.set_value/3","doc":"* **Automatic recomputation** - Setting a value triggers recomputation of all dependent nodes\n* **Idempotent** - Setting the same value twice has no effect (no revision increment)\n* **Input nodes only** - Only input nodes can be set; compute nodes are read-only","ref":"Journey.html#set_value/3-key-behaviors"},{"type":"function","title":"Quick Example - Journey.set_value/3","doc":"```elixir\nexecution = Journey.set_value(execution, :name, \"Mario\")\n{:ok, greeting} = Journey.get_value(execution, :greeting, wait_any: true)\n```\n\nUse `get_value/3` to retrieve the set value and `unset_value/2` to remove values.","ref":"Journey.html#set_value/3-quick-example"},{"type":"function","title":"Examples - Journey.set_value/3","doc":"Basic setting with cascading recomputation:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"set workflow - cascading example\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         compute(:greeting, [:name], fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end)\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :name, \"Mario\")\niex> Journey.get_value(execution, :greeting, wait_any: true)\n{:ok, \"Hello, Mario!\"}\niex> execution = Journey.set_value(execution, :name, \"Luigi\")\niex> Journey.get_value(execution, :greeting, wait_new: true)\n{:ok, \"Hello, Luigi!\"}\n```\n\nIdempotent behavior - same value doesn't change revision:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"set workflow - idempotent example\",\n...>       \"v1.0.0\",\n...>       [input(:name)]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :name, \"Mario\")\niex> first_revision = execution.revision\niex> execution = Journey.set_value(execution, :name, \"Mario\")\niex> execution.revision == first_revision\ntrue\n```\n\nDifferent value types:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"set workflow - value types example\",\n...>       \"v1.0.0\",\n...>       [input(:number), input(:flag), input(:data)]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :number, 42)\niex> execution = Journey.set_value(execution, :flag, true)\niex> execution = Journey.set_value(execution, :data, %{key: \"value\"})\niex> Journey.get_value(execution, :number)\n{:ok, 42}\niex> Journey.get_value(execution, :flag)\n{:ok, true}\n```\n\nUsing an execution ID:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"set workflow - execution_id example\",\n...>       \"v1.0.0\",\n...>       [input(:name)]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> updated_execution = Journey.set_value(execution.id, :name, \"Luigi\")\niex> Journey.get_value(updated_execution, :name)\n{:ok, \"Luigi\"}\n```","ref":"Journey.html#set_value/3-examples"},{"type":"function","title":"Journey.start_execution/1","doc":"Starts a new execution instance of a computation graph, initializing it to accept input values and perform computations.\n\nCreates a persistent execution in the database with a unique ID and begins background processing\nfor any schedulable nodes. The execution starts with revision 0 and no values set.","ref":"Journey.html#start_execution/1"},{"type":"function","title":"Quick Example - Journey.start_execution/1","doc":"```elixir\nexecution = Journey.start_execution(graph)\nexecution = Journey.set_value(execution, :name, \"Mario\")\n{:ok, greeting} = Journey.get_value(execution, :greeting, wait_any: true)\n```\n\nUse `set_value/3` to provide input values and `get_value/3` to retrieve computed results.","ref":"Journey.html#start_execution/1-quick-example"},{"type":"function","title":"Parameters - Journey.start_execution/1","doc":"* `graph` - A validated `%Journey.Graph{}` struct created with `new_graph/3`. The graph must\n  have passed validation during creation and be registered in the graph catalog.","ref":"Journey.html#start_execution/1-parameters"},{"type":"function","title":"Returns - Journey.start_execution/1","doc":"* A new `%Journey.Persistence.Schema.Execution{}` struct with:\n  * `:id` - Unique execution identifier (UUID string)\n  * `:graph_name` and `:graph_version` - From the source graph\n  * `:revision` - Always starts at 0, increments with each state change\n  * `:archived_at` - Initially nil (not archived)\n  and other fields.","ref":"Journey.html#start_execution/1-returns"},{"type":"function","title":"Key Behaviors - Journey.start_execution/1","doc":"* **Database persistence** - Execution state is immediately saved to PostgreSQL\n* **Unique execution** - Each call creates a completely independent execution instance\n* **Background processing** - Scheduler automatically begins monitoring for schedulable nodes\n* **Ready for inputs** - Can immediately accept input values via `set_value/3`","ref":"Journey.html#start_execution/1-key-behaviors"},{"type":"function","title":"Examples - Journey.start_execution/1","doc":"Basic execution creation:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"greeting workflow\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         compute(\n...>           :greeting,\n...>           [:name],\n...>           fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end\n...>         )\n...>       ]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> execution.graph_name\n\"greeting workflow\"\niex> execution.graph_version\n\"v1.0.0\"\niex> execution.revision\n0\n```\n\nExecution properties and immediate workflow:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"calculation workflow\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:x),\n...>         input(:y),\n...>         compute(:sum, [:x, :y], fn %{x: x, y: y} -> {:ok, x + y} end)\n...>       ]\n...>     )\niex> execution = Journey.start_execution(graph)\niex> is_binary(execution.id)\ntrue\niex> execution.archived_at\nnil\niex> user_values = Journey.values(execution, reload: false) |> Map.drop([:execution_id, :last_updated_at])\niex> user_values\n%{}\niex> execution = Journey.set_value(execution, :x, 10)\niex> execution = Journey.set_value(execution, :y, 20)\niex> Journey.get_value(execution, :sum, wait_any: true)\n{:ok, 30}\n```\n\nMultiple independent executions:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"counter workflow\",\n...>       \"v1.0.0\",\n...>       [input(:count)]\n...>     )\niex> execution1 = Journey.start_execution(graph)\niex> execution2 = Journey.start_execution(graph)\niex> execution1.id != execution2.id\ntrue\niex> execution1 = Journey.set_value(execution1, :count, 1)\niex> execution2 = Journey.set_value(execution2, :count, 2)\niex> Journey.get_value(execution1, :count)\n{:ok, 1}\niex> Journey.get_value(execution2, :count)\n{:ok, 2}\n```","ref":"Journey.html#start_execution/1-examples"},{"type":"function","title":"Journey.unarchive/1","doc":"Un-archives the supplied execution, if it is archived.","ref":"Journey.html#unarchive/1"},{"type":"function","title":"Parameters: - Journey.unarchive/1","doc":"- `execution` or `execution_id`: The execution to un-archive, or the ID of the execution to un-archive.\n\nReturns\n* :ok","ref":"Journey.html#unarchive/1-parameters"},{"type":"function","title":"Examples - Journey.unarchive/1","doc":"```elixir\n  iex> execution =\n  ...>    Journey.Examples.Horoscope.graph() |>\n  ...>    Journey.start_execution() |>\n  ...>    Journey.set_value(:birth_day, 26)\n  iex> _archived_at = Journey.archive(execution)\n  iex> # The execution is now archived, and it is no longer visible.\n  iex> nil == Journey.load(execution, include_archived: false)\n  true\n  iex> Journey.unarchive(execution)\n  :ok\n  iex> # The execution is now un-archived, and it can now be loaded.\n  iex> nil == Journey.load(execution, include_archived: false)\n  false\n  iex> # Un-archiving an un-archived execution has no effect.\n  iex> Journey.unarchive(execution)\n  :ok\n  ```","ref":"Journey.html#unarchive/1-examples"},{"type":"function","title":"Journey.unset_value/2","doc":"Removes the value from an input node in an execution and invalidates all dependent computed nodes.\n\nWhen a value is unset, Journey automatically invalidates (unsets) all computed nodes that depend\non the unset input, creating a cascading effect through the dependency graph. This ensures data\nconsistency - no computed values remain that were based on the now-removed input.","ref":"Journey.html#unset_value/2"},{"type":"function","title":"Quick Example - Journey.unset_value/2","doc":"```elixir\nexecution = Journey.unset_value(execution, :name)\n{:error, :not_set} = Journey.get_value(execution, :name)\n```\n\nUse `set_value/3` to set values and `get_value/3` to check if values are set.","ref":"Journey.html#unset_value/2-quick-example"},{"type":"function","title":"Parameters - Journey.unset_value/2","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct or execution ID string\n* `node_name` - Atom representing the input node name (must exist in the graph)","ref":"Journey.html#unset_value/2-parameters"},{"type":"function","title":"Returns - Journey.unset_value/2","doc":"* Updated `%Journey.Persistence.Schema.Execution{}` struct with incremented revision (if value was set)","ref":"Journey.html#unset_value/2-returns"},{"type":"function","title":"Errors - Journey.unset_value/2","doc":"* Raises `RuntimeError` if the node name does not exist in the execution's graph\n* Raises `RuntimeError` if attempting to unset a compute node (only input nodes can be unset)","ref":"Journey.html#unset_value/2-errors"},{"type":"function","title":"Key Behaviors - Journey.unset_value/2","doc":"* **Cascading invalidation** - Dependent computed nodes are automatically unset\n* **Idempotent** - Multiple unsets of the same value have no additional effect\n* **Input nodes only** - Only input nodes can be unset; compute nodes cannot be unset","ref":"Journey.html#unset_value/2-key-behaviors"},{"type":"function","title":"Examples - Journey.unset_value/2","doc":"Basic unsetting with cascading invalidation:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"unset workflow - basic example\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         compute(\n...>           :greeting,\n...>           [:name],\n...>           fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end\n...>         )\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :name, \"Mario\")\niex> Journey.get_value(execution, :greeting, wait_any: true)\n{:ok, \"Hello, Mario!\"}\niex> execution_after_unset = Journey.unset_value(execution, :name)\niex> Journey.get_value(execution_after_unset, :name)\n{:error, :not_set}\niex> Journey.get_value(execution_after_unset, :greeting)\n{:error, :not_set}\n```\n\nMulti-level cascading (A â†’ B â†’ C chain):\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"unset workflow - cascade example\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:a),\n...>         compute(:b, [:a], fn %{a: a} -> {:ok, \"B:#{a}\"} end),\n...>         compute(:c, [:b], fn %{b: b} -> {:ok, \"C:#{b}\"} end)\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :a, \"value\")\niex> Journey.get_value(execution, :b, wait_any: true)\n{:ok, \"B:value\"}\niex> Journey.get_value(execution, :c, wait_any: true)\n{:ok, \"C:B:value\"}\niex> execution_after_unset = Journey.unset_value(execution, :a)\niex> Journey.get_value(execution_after_unset, :a)\n{:error, :not_set}\niex> Journey.get_value(execution_after_unset, :b)\n{:error, :not_set}\niex> Journey.get_value(execution_after_unset, :c)\n{:error, :not_set}\n```\n\nIdempotent behavior:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>   \"unset workflow - idempotent example\",\n...>   \"v1.0.0\",\n...>   [input(:name)]\n...> )\niex> execution = graph |> Journey.start_execution()\niex> original_revision = execution.revision\niex> execution_after_unset = Journey.unset_value(execution, :name)\niex> execution_after_unset.revision == original_revision\ntrue\n```","ref":"Journey.html#unset_value/2-examples"},{"type":"function","title":"Journey.values/2","doc":"Returns a map of all set node values in an execution, excluding unset nodes.\n\nThis function filters the execution to only include nodes that have been populated with data.\nUnset nodes are excluded from the result. Always includes `:execution_id` and `:last_updated_at` metadata.","ref":"Journey.html#values/2"},{"type":"function","title":"Quick Example - Journey.values/2","doc":"```elixir\nexecution = Journey.set_value(execution, :name, \"Alice\")\nvalues = Journey.values(execution)\n# %{name: \"Alice\", execution_id: \"EXEC...\", last_updated_at: 1234567890}\n```\n\nUse `values_all/1` to see all nodes including unset ones, or `get_value/3` for individual values.","ref":"Journey.html#values/2-quick-example"},{"type":"function","title":"Parameters - Journey.values/2","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct\n* `opts` - Keyword list of options (`:reload` - see `values_all/1` for details)","ref":"Journey.html#values/2-parameters"},{"type":"function","title":"Returns - Journey.values/2","doc":"* Map with node names as keys and their current values as values\n* Only includes nodes that have been set (excludes `:not_set` nodes)","ref":"Journey.html#values/2-returns"},{"type":"function","title":"Examples - Journey.values/2","doc":"Basic usage:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\"example\", \"v1.0.0\", [input(:name), input(:age)])\niex> execution = Journey.start_execution(graph)\niex> Journey.values(execution) |> redact([:execution_id, :last_updated_at])\n%{execution_id: \"...\", last_updated_at: 1234567890}\niex> execution = Journey.set_value(execution, :name, \"Alice\")\niex> Journey.values(execution) |> redact([:execution_id, :last_updated_at])\n%{name: \"Alice\", execution_id: \"...\", last_updated_at: 1234567890}\n```","ref":"Journey.html#values/2-examples"},{"type":"function","title":"Journey.values_all/2","doc":"Returns a map of all nodes in an execution with their current status, including unset nodes.\n\nUnlike `values/2` which only returns set nodes, this function shows all nodes including those\nthat haven't been set yet. Unset nodes are marked as `:not_set`, while set nodes are returned\nas `{:set, value}` tuples. Useful for debugging and introspection.","ref":"Journey.html#values_all/2"},{"type":"function","title":"Quick Example - Journey.values_all/2","doc":"```elixir\nall_status = Journey.values_all(execution)\n# %{name: {:set, \"Alice\"}, age: :not_set, execution_id: {:set, \"EXEC...\"}, ...}\n```\n\nUse `values/2` to get only set values, or `get_value/3` for individual node values.","ref":"Journey.html#values_all/2-quick-example"},{"type":"function","title":"Parameters - Journey.values_all/2","doc":"* `execution` - A `%Journey.Persistence.Schema.Execution{}` struct\n* `opts` - Keyword list of options (`:reload` - defaults to `true` for fresh database state)","ref":"Journey.html#values_all/2-parameters"},{"type":"function","title":"Returns - Journey.values_all/2","doc":"* Map with all nodes showing status: `:not_set` or `{:set, value}`\n* Includes all nodes defined in the graph, regardless of current state","ref":"Journey.html#values_all/2-returns"},{"type":"function","title":"Examples - Journey.values_all/2","doc":"Basic usage showing status progression:\n\n```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\"example\", \"v1.0.0\", [input(:name), input(:age)])\niex> execution = Journey.start_execution(graph)\niex> Journey.values_all(execution) |> redact([:execution_id, :last_updated_at])\n%{name: :not_set, age: :not_set, execution_id: {:set, \"...\"}, last_updated_at: {:set, 1234567890}}\niex> execution = Journey.set_value(execution, :name, \"Alice\")\niex> Journey.values_all(execution) |> redact([:execution_id, :last_updated_at])\n%{name: {:set, \"Alice\"}, age: :not_set, execution_id: {:set, \"...\"}, last_updated_at: {:set, 1234567890}}\n```","ref":"Journey.html#values_all/2-examples"},{"type":"module","title":"Journey.Examples.CreditCardApplication","doc":"This module demonstrates building a simple credit card application workflow using the Journey library.\n\nYou might find it interesting to read the actual source code of this example (the definition of the graph, and the \"business logic\" functions), but here is a doctest illustrating executing a credit card application workflow.","ref":"Journey.Examples.CreditCardApplication.html"},{"type":"module","title":"Examples: - Journey.Examples.CreditCardApplication","doc":"```elixir\niex> # The customer starts the application process and provides their personal information.\niex> import Journey.Node\niex> graph = Journey.Examples.CreditCardApplication.graph()\niex> execution = Journey.start_execution(graph)\niex>\niex> # This is only needed in a test, to perform background processing that happens automatically outside of tests.\niex> background_sweeps_task = Journey.Scheduler.Background.Periodic.start_background_sweeps_in_test(execution.id)\niex>\niex> execution = execution |> Journey.set_value(:full_name, \"Mario\")\niex> execution = execution |> Journey.set_value(:birth_date, \"10/11/1981\")\niex> execution = execution |> Journey.set_value(:ssn, \"123-45-6789\")\niex> execution = execution |> Journey.set_value(:email_address, \"mario@example.com\")\niex>\niex> # This kicks off the pre-approval process, which eventually completes.\niex> execution |> Journey.get_value(:preapproval_process_completed, wait_any: true)\n{:ok, true}\niex> # We haven't heard from the customer, so we'll send a reminder in a few days (seconds;).\niex> execution |> Journey.get_value(:send_preapproval_reminder, wait_any: true)\n{:ok, true}\niex>\niex> # Reminded, the customer requests an actual credit card.\niex> _execution = execution |> Journey.set_value(:credit_card_requested, true)\niex> # ... which triggers issuing the card.\niex>\niex> execution |> Journey.get_value(:initiate_credit_card_issuance, wait_any: true)\n{:ok, true}\niex> execution |> Journey.values() |> redact([:schedule_request_credit_card_reminder, :execution_id, :last_updated_at])\n%{\n    preapproval_process_completed: true,\n    birth_date: \"10/11/1981\",\n    congratulate: \"email_sent_congrats\",\n    preapproval_decision: \"approved\",\n    credit_score: 800,\n    email_address: \"mario@example.com\",\n    full_name: \"Mario\",\n    ssn: \" \",\n    ssn_redacted: \"updated :ssn\",\n    credit_card_requested: true,\n    initiate_credit_card_issuance: true,\n    schedule_request_credit_card_reminder: 1234567890,\n    execution_id: \"...\",\n    last_updated_at: 1234567890\n  }\niex>\niex> # Eventually, the fulfillment department marks the credit card as mailed.\niex> # Which triggers an email notifying the customer that the card has been mailed.\niex> execution = execution |> Journey.set_value(:credit_card_mailed, true)\niex> execution |> Journey.get_value(:credit_card_mailed_notification, wait_any: true)\n{:ok, true}\niex> {:ok, _} = execution |> Journey.get_value(:archive, wait_any: true)\niex> # This is only needed in tests.\niex> Journey.Scheduler.Background.Periodic.stop_background_sweeps_in_test(background_sweeps_task)\n\n```","ref":"Journey.Examples.CreditCardApplication.html#module-examples"},{"type":"function","title":"Journey.Examples.CreditCardApplication.graph/0","doc":"This function defines the graph for the credit card application workflow.\n\nThe graph is defined as a list of nodes.\nInput nodes have a name.\nComputation nodes also have upstream dependencies and a function to compute the node's value, and a few other options.","ref":"Journey.Examples.CreditCardApplication.html#graph/0"},{"type":"module","title":"Journey.Examples.CreditCardApplication.Compute","doc":"This module contains the business logic for the Credit Card Approval application, things like fetching the customer's credit score, making and communication the credit decision, etc.","ref":"Journey.Examples.CreditCardApplication.Compute.html"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.all_done/1","doc":"This function marks the flow as completed when it's all done.","ref":"Journey.Examples.CreditCardApplication.Compute.html#all_done/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.choose_the_time_to_archive/1","doc":"This function schedules archiving the execution.","ref":"Journey.Examples.CreditCardApplication.Compute.html#choose_the_time_to_archive/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.choose_the_time_to_send_reminder/1","doc":"This function simulates scheduling sending a reminder to preapproved customers.","ref":"Journey.Examples.CreditCardApplication.Compute.html#choose_the_time_to_send_reminder/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.compute_decision/1","doc":"This function simulates computing the credit decision, based on the credit score.","ref":"Journey.Examples.CreditCardApplication.Compute.html#compute_decision/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.fetch_credit_score/1","doc":"This function simulates fetching a credit score from an external service.","ref":"Journey.Examples.CreditCardApplication.Compute.html#fetch_credit_score/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.request_credit_card_issuance/1","doc":"This function simulates initiating the issuance and mailing of a credit card.","ref":"Journey.Examples.CreditCardApplication.Compute.html#request_credit_card_issuance/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.send_card_mailed_notification/1","doc":"This function simulates emailing the customer and telling them that the card has been mailed.","ref":"Journey.Examples.CreditCardApplication.Compute.html#send_card_mailed_notification/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.send_congrats/1","doc":"This function simulates sending the customer an email when their application was approved.","ref":"Journey.Examples.CreditCardApplication.Compute.html#send_congrats/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.send_preapproval_reminder/1","doc":"This function simulates sending the preapproved customer a reminder to request a credit card.","ref":"Journey.Examples.CreditCardApplication.Compute.html#send_preapproval_reminder/1"},{"type":"function","title":"Journey.Examples.CreditCardApplication.Compute.send_rejection/1","doc":"This function simulates sending the customer an email when their application was declined.","ref":"Journey.Examples.CreditCardApplication.Compute.html#send_rejection/1"},{"type":"module","title":"Journey.Insights.FlowAnalytics","doc":"Provides system-wide aggregate data about the state of the executions of a particular graph.\nThis can be thought of as \"analytics\" for a particular graph.","ref":"Journey.Insights.FlowAnalytics.html"},{"type":"function","title":"Journey.Insights.FlowAnalytics.flow_analytics/3","doc":"Provides business-focused analytics for understanding customer behavior through Journey graphs.\n\nUses optimized database queries that scale efficiently to millions of executions by leveraging\nPostgreSQL's aggregation capabilities. System nodes (execution_id and last_updated_at) are\nautomatically excluded from the analysis.","ref":"Journey.Insights.FlowAnalytics.html#flow_analytics/3"},{"type":"function","title":"Parameters - Journey.Insights.FlowAnalytics.flow_analytics/3","doc":"- `graph_name` - String, the graph name to analyze\n- `graph_version` - String, the graph version to analyze\n- `opts` - Keyword list with options:\n  - `:include_executions` - `:all` | `:archived` | `:active` (default: `:active`)\n  - `:flow_ends_here_after` - Duration in seconds after which we consider a flow \"ended\" if no activity (default: 86400 seconds / 1 day)","ref":"Journey.Insights.FlowAnalytics.html#flow_analytics/3-parameters"},{"type":"function","title":"Return Structure - Journey.Insights.FlowAnalytics.flow_analytics/3","doc":"Returns a map with graph metadata, execution-level analytics, and per-node customer journey metrics.","ref":"Journey.Insights.FlowAnalytics.html#flow_analytics/3-return-structure"},{"type":"function","title":"Examples - Journey.Insights.FlowAnalytics.flow_analytics/3","doc":"iex(3)> Journey.Insights.FlowAnalytics.flow_analytics(\"Credit Card Application flow graph\", \"v1.0.0\")\n  %{\n    graph_name: \"Credit Card Application flow graph\",\n    analyzed_at: \"2025-08-02T04:08:28.351195Z\",\n    executions: %{\n      count: 8294,\n      duration_avg_seconds_to_last_update: 48,\n      duration_median_seconds_to_last_update: 0\n    },\n    graph_version: \"v1.0.0\",\n    node_stats: %{\n      nodes: [\n        %{\n          node_type: :input,\n          node_name: :birth_date,\n          # The number of executions that have set a value for this node.\n          reached_count: 3884,\n          # The average time it took for an execution to reach this node.\n          average_time_to_reach: 1,\n          # The number of executions which haven't been updated for a while, and this was the last node that was updated.\n          flow_ends_here_count: 1953,\n          # The percentage of all executions that ended here.\n          flow_ends_here_percentage_of_all: 23.5,\n          # The percentage of executions that reached this node and ended here.\n          flow_ends_here_percentage_of_reached: 50.28,\n          # The percentage of executions that have set a value for this node.\n          reached_percentage: 46.8\n        },\n        %{\n          node_type: :input,\n          node_name: :email_address,\n          reached_count: 2066,\n          average_time_to_reach: 0,\n          flow_ends_here_count: 213,\n          flow_ends_here_percentage_of_all: 2.6,\n          flow_ends_here_percentage_of_reached: 10.31,\n          reached_percentage: 24.9\n        },\n        %{\n          node_type: :input,\n          node_name: :full_name,\n          reached_count: 5736,\n          average_time_to_reach: 0,\n          flow_ends_here_count: 3716,\n          flow_ends_here_percentage_of_all: 44.8,\n          flow_ends_here_percentage_of_reached: 64.78,\n          reached_percentage: 69.2\n        },\n        %{\n          node_type: :compute,\n          node_name: :credit_score,\n          reached_count: 1844,\n          average_time_to_reach: 1,\n          flow_ends_here_count: 0,\n          flow_ends_here_percentage_of_all: 0.0,\n          flow_ends_here_percentage_of_reached: 0.0,\n          reached_percentage: 22.2\n        },\n        ...\n      ]\n    }\n  }","ref":"Journey.Insights.FlowAnalytics.html#flow_analytics/3-examples"},{"type":"function","title":"Journey.Insights.FlowAnalytics.to_text/1","doc":"Formats flow analytics data as human-readable text output.","ref":"Journey.Insights.FlowAnalytics.html#to_text/1"},{"type":"function","title":"Example: - Journey.Insights.FlowAnalytics.to_text/1","doc":"iex> flow_data = Journey.Insights.FlowAnalytics.flow_analytics(\"Credit Card Application flow graph\", \"v1.0.0\")\n    iex> Journey.Insights.FlowAnalytics.to_text(flow_data) |> IO.puts()\n    Graph: 'Credit Card Application flow graph'\n    Version: 'v1.0.0'\n    Analyzed at: 2025-08-02T04:08:28Z\n\n    EXECUTION STATS:\n    ----------\n    Total executions: 8,294\n    Average duration: 48 seconds\n    Median duration: 0 seconds\n\n    NODE STATS (4 nodes):\n    ----------\n    Node Name: 'birth_date'\n    Type: input\n    Reached by: 3,884 executions (46.8%)\n    Average time to reach: 1 second\n    Flow ends here: 1,953 executions (23.5% of all, 50.3% of reached)\n\n    Node Name: 'email_address'\n    Type: input\n    Reached by: 2,066 executions (24.9%)\n    Average time to reach: 0 seconds\n    Flow ends here: 213 executions (2.6% of all, 10.3% of reached)\n\n    Node Name: 'full_name'\n    Type: input\n    Reached by: 5,736 executions (69.2%)\n    Average time to reach: 0 seconds\n    Flow ends here: 3,716 executions (44.8% of all, 64.8% of reached)\n\n    Node Name: 'credit_score'\n    Type: compute\n    Reached by: 1,844 executions (22.2%)\n    Average time to reach: 1 second\n    Flow ends here: 0 executions (0.0% of all, 0.0% of reached)","ref":"Journey.Insights.FlowAnalytics.html#to_text/1-example"},{"type":"module","title":"Journey.Insights.Status","doc":"Provides system health and monitoring insights for Journey executions.","ref":"Journey.Insights.Status.html"},{"type":"function","title":"Journey.Insights.Status.status/0","doc":"Returns current system health for monitoring/alerting","ref":"Journey.Insights.Status.html#status/0"},{"type":"function","title":"Response Structure - Journey.Insights.Status.status/0","doc":"- `status` - `:healthy` or `:unhealthy`\n- `database_connected` - Boolean indicating DB connectivity\n- `graphs` - List of graph statistics, one per graph name/version","ref":"Journey.Insights.Status.html#status/0-response-structure"},{"type":"function","title":"Example output: - Journey.Insights.Status.status/0","doc":"```elixir\n%{\n  status: :healthy,\n  graphs: [\n    %{\n      stats: %{\n        computations: %{\n          by_state: %{\n            abandoned: 239,\n            cancelled: 0,\n            success: 21106,\n            failed: 0,\n            not_set: 59294,\n            computing: 0\n          },\n          most_recently_created: \"2025-07-30T00:07:37Z\",\n          most_recently_updated: \"2025-07-30T00:07:41Z\"\n        },\n        executions: %{\n          active: 4597,\n          most_recently_created: \"2025-07-30T00:07:37Z\",\n          most_recently_updated: \"2025-07-30T00:07:41Z\",\n          archived: 2103\n        }\n      },\n      graph_name: \"Credit Card Application flow graph\",\n      graph_version: \"v1.0.0\"\n    }\n  ],\n  database_connected: true\n}\n```","ref":"Journey.Insights.Status.html#status/0-example-output"},{"type":"function","title":"Journey.Insights.Status.to_text/1","doc":"Formats status data as human-readable text output.","ref":"Journey.Insights.Status.html#to_text/1"},{"type":"function","title":"Example: - Journey.Insights.Status.to_text/1","doc":"iex> status_data = Journey.Insights.Status.status()\n    iex> Journey.Insights.Status.to_text(status_data) |> IO.puts()\n    System Status: HEALTHY\n    Database: Connected\n    ================================================================================\n\n    GRAPHS (3 total):\n    ----------\n\n    Name: 'Credit Card Application flow graph'\n    Version: 'v1.0.0'\n    Executions:\n    - active: 12.7k\n    - archived: 5.1k\n    First activity: 2025-07-28T19:50:40Z\n    Last activity: 2025-08-14T05:31:05Z\n    Computations:\n    âœ“ success: 61.4k\n    âœ— failed: 0\n    â³ computing: 33\n    â—¯ not_set: 151.7k\n    âš  abandoned: 1.0k\n\n    ---------\n\n    Name: 'flow_analytics_perf_test'\n    Version: '1.0.0'\n    Executions:\n    - active: 900\n    - archived: 100\n    First activity: 2025-08-01T22:05:06Z\n    Last activity: 2025-08-01T22:05:09Z\n    Computations:\n    âœ“ success: 1.7k\n    â³ computing: 54\n    â—¯ not_set: 2.3k\n\n    ---------\n\n    Name: 'g1'\n    Version: 'v1'\n    Executions:\n    - active: 25\n    - archived: 0\n    First activity: 2025-08-14T17:23:16Z\n    Last activity: 2025-08-14T17:29:36Z\n    Computations:\n    âœ“ success: 38\n    âœ— failed: 7\n    â—¯ not_set: 4\n    âš  abandoned: 2","ref":"Journey.Insights.Status.html#to_text/1-example"},{"type":"module","title":"Journey.Node","doc":"This module contains functions for creating nodes in a graph.\nNodes in a graph can be of several types:\n* `input/1` â€“ a node that takes input from the user.\n* `compute/4` â€“ a node that computes a value based on its upstream nodes.\n* `mutate/4` â€“ a node that mutates the value of another node.\n* `schedule_once/3` â€“ a node that, once unblocked, in its turn, unblocks others, on a schedule.\n* `schedule_recurring/3` â€“ a node that, once unblocked, in its turn, unblocks others, on a schedule, time after time.","ref":"Journey.Node.html"},{"type":"function","title":"Journey.Node.archive/3","doc":"Creates a graph node that mutates the value of another node.","ref":"Journey.Node.html#archive/3"},{"type":"function","title":"Examples: - Journey.Node.archive/3","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`archive()` doctest graph (a useless machine that archives itself immediately;)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         archive(:archive, [:name])\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution.archived_at == nil\ntrue\niex> execution = Journey.set_value(execution, :name, \"Mario\")\niex> {:ok, _} = Journey.get_value(execution, :archive, wait_any: true)\niex> Journey.load(execution)\nnil\niex> execution = Journey.load(execution, include_archived: true)\niex> execution.archived_at == nil\nfalse\n```","ref":"Journey.Node.html#archive/3-examples"},{"type":"function","title":"Journey.Node.compute/4","doc":"Creates a self-computing node.\n\n`name` is an atom uniquely identifying the node in this graph.\n\n`gated_by` defines when this node becomes eligible to compute.\n  Accepts either:\n  - A list of atom node names, e.g. `[:a, :b]`, indicating the node becomes unblocked when all of the listed nodes have a value.\n  - A keyword list with conditions, e.g. `[a: fn node -> node.node_value > 10 end]`, for conditional dependencies.\n  - A mixed list combining atoms and keyword conditions, e.g. `[:a, :b, c: fn node -> node.node_value > 5 end]`.\n  - A structured condition (see [unblocked_when/1](`Journey.Node.UpstreamDependencies.unblocked_when/1`) )\n    allowing for logical operators (`:and`, `:or`) and custom value predicates (e.g. `unblocked_when({:and, [{:a, &provided?/1}, {:b, &provided?/1}]})`).\n\n`f_compute` is the function that computes the value of the node, once the upstream dependencies are satisfied.\nThe function is provided a map of the upstream nodes and their values as its argument and returns a tuple:\n - `{:ok, value}` or\n - `{:error, reason}`.\nThe function is called when the upstream nodes are set, and the value is set to the result of the function.\n\nNote that return values are JSON-serialized for storage. If the returned `value` or `reason` contains atoms \n(e.g., `{:ok, :pending}` or `{:ok, %{status: :active}}`), those atoms will be converted to \nstrings when retrieved via `get_value/3`.\n\nIn the case of a failure, the function is automatically retried, up to `max_retries` times.\nIf the function fails after `max_retries` attempts, the node is marked as failed.\nIf the function does not return within `abandon_after_seconds`, it is considered abandoned, and it will be retried (up to `max_retries` times).","ref":"Journey.Node.html#compute/4"},{"type":"function","title":"Examples: - Journey.Node.compute/4","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`compute()` doctest graph (pig-latinize-ish a name)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         compute(\n...>           :pig_latin_ish_name,\n...>           [:name],\n...>           fn %{name: name} ->\n...>             {:ok, \"#{name}-ay\"}\n...>           end,\n...>           max_retries: 4, # Optional (default: 3)\n...>           abandon_after_seconds: 60, # Optional (default: 60)\n...>           f_on_save: fn _execution_id, _params ->\n...>             # Optional callback to be called when the value is saved.\n...>             # This is useful for notifying other systems (e.g. a LiveView\n...>             # via PubSub.notify()) â€“Â that the value has been saved.\n...>             :ok\n...>           end\n...>         )\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution() |> Journey.set_value(:name, \"Alice\")\niex> execution |> Journey.get_value(:pig_latin_ish_name, wait_any: true)\n{:ok, \"Alice-ay\"}\niex> execution |> Journey.values() |> redact([:execution_id, :last_updated_at])\n%{name: \"Alice\", pig_latin_ish_name: \"Alice-ay\", execution_id: \"...\", last_updated_at: 1_234_567_890}\n```","ref":"Journey.Node.html#compute/4-examples"},{"type":"function","title":"Keyword List Syntax for Conditional Dependencies - Journey.Node.compute/4","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"threshold alert example\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:temperature),\n...>         # Using keyword list syntax for conditional dependency\n...>         compute(\n...>           :high_temp_alert,\n...>           [temperature: fn node -> node.node_value > 30 end],\n...>           fn %{temperature: temp} ->\n...>             {:ok, \"High temperature alert: #{temp}Â°C\"}\n...>           end\n...>         )\n...>       ]\n...>     )\niex> execution = graph |> Journey.start_execution()\niex> execution = Journey.set_value(execution, :temperature, 25)\niex> Journey.get_value(execution, :high_temp_alert)\n{:error, :not_set}\niex> execution = Journey.set_value(execution, :temperature, 35)\niex> Journey.get_value(execution, :high_temp_alert, wait_any: true)\n{:ok, \"High temperature alert: 35Â°C\"}\n```","ref":"Journey.Node.html#compute/4-keyword-list-syntax-for-conditional-dependencies"},{"type":"function","title":"Return Values - Journey.Node.compute/4","doc":"The f_compute function must return `{:ok, value}` or `{:error, reason}`. Note that atoms \nin the returned `value` and `reason` will be converted to strings when persisted.","ref":"Journey.Node.html#compute/4-return-values"},{"type":"function","title":"Journey.Node.input/1","doc":"Creates a graph input node. The value of an input node is set with `Journey.set_value/3`. The name of the node must be an atom.","ref":"Journey.Node.html#input/1"},{"type":"function","title":"Examples: - Journey.Node.input/1","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`input()` doctest graph (just a few input nodes)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:first_name),\n...>         input(:last_name),\n...>         input(:zip_code)\n...>        ]\n...>     )\niex> execution = graph |> Journey.start_execution() |> Journey.set_value(:first_name, \"Mario\")\niex> Journey.values(execution) |> redact([:execution_id, :last_updated_at])\n%{first_name: \"Mario\", execution_id: \"...\", last_updated_at: 1_234_567_890}\n```","ref":"Journey.Node.html#input/1-examples"},{"type":"function","title":"Journey.Node.mutate/4","doc":"Creates a graph node that mutates the value of another node.","ref":"Journey.Node.html#mutate/4"},{"type":"function","title":"Examples: - Journey.Node.mutate/4","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`mutate()` doctest graph (a useless machine;)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         mutate(\n...>           :remove_pii,\n...>           [:name],\n...>           fn %{name: _name} ->\n...>             # Return the new value for the \"name\" node.\n...>             {:ok, \"redacted\"}\n...>           end,\n...>           mutates: :name # The name of an existing node whose value will be mutated.\n...>         )\n...>       ]\n...>     )\niex> execution =\n...>     graph\n...>     |> Journey.start_execution()\n...>     |> Journey.set_value(:name, \"Mario\")\niex> execution |> Journey.get_value(:remove_pii, wait_any: true)\n{:ok, \"updated :name\"}\niex> execution |> Journey.values() |> redact([:execution_id, :last_updated_at])\n%{name: \"redacted\", remove_pii: \"updated :name\",  execution_id: \"...\", last_updated_at: 1_234_567_890}\n```","ref":"Journey.Node.html#mutate/4-examples"},{"type":"function","title":"Return Values - Journey.Node.mutate/4","doc":"The f_compute function must return `{:ok, value}` or `{:error, reason}`. Note that atoms \nin the returned `value` and `reason` will be converted to strings when persisted.","ref":"Journey.Node.html#mutate/4-return-values"},{"type":"function","title":"Journey.Node.schedule_once/4","doc":"Creates a graph node that declares its readiness at a specific time, once.\n\nOnce this node is unblocked, it will be executed to set the time at which it will unblock its downstream dependencies.","ref":"Journey.Node.html#schedule_once/4"},{"type":"function","title":"Examples: - Journey.Node.schedule_once/4","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`schedule_once()` doctest graph (it reminds you to take a nap in a couple of seconds;)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         schedule_once(\n...>           :schedule_a_nap,\n...>           [:name],\n...>           fn %{name: _name} ->\n...>             # This function is to return the time (in epoch seconds) at which\n...>             # its downstream dependencies should be unblocked.\n...>             in_two_seconds = System.system_time(:second) + 2\n...>             {:ok, in_two_seconds}\n...>           end\n...>         ),\n...>         compute(\n...>           :nap_time,\n...>           [:name, :schedule_a_nap],\n...>           fn %{name: name, schedule_a_nap: _time_to_take_a_nap} ->\n...>             {:ok, \"It's time to take a nap, #{name}!\"}\n...>           end\n...>         )\n...>       ]\n...>     )\niex> execution =\n...>     graph\n...>     |> Journey.start_execution()\n...>     |> Journey.set_value(:name, \"Mario\")\niex> execution |> Journey.values() |> Map.get(:name)\n\"Mario\"\niex> # This is only needed in a test, to simulate the background processing that happens in non-tests automatically.\niex> background_sweeps_task = Journey.Scheduler.Background.Periodic.start_background_sweeps_in_test(execution.id)\niex> execution |> Journey.get_value(:nap_time, wait_any: true)\n{:ok, \"It's time to take a nap, Mario!\"}\niex> Journey.Scheduler.Background.Periodic.stop_background_sweeps_in_test(background_sweeps_task)\n\n```","ref":"Journey.Node.html#schedule_once/4-examples"},{"type":"function","title":"Return Values - Journey.Node.schedule_once/4","doc":"The f_compute function must return `{:ok, value}` or `{:error, reason}`. Note that atoms \nin the returned `value` and `reason` will be converted to strings when persisted.","ref":"Journey.Node.html#schedule_once/4-return-values"},{"type":"function","title":"Journey.Node.schedule_recurring/4","doc":"Creates a graph node that declares its readiness at a specific time, time after time.\n\nOnce this node is unblocked, it will be repeatedly computed, to set the time at which it will unblock its downstream dependencies.\n\nThis is useful for triggering recurring tasks, such as sending reminders or notifications.","ref":"Journey.Node.html#schedule_recurring/4"},{"type":"function","title":"Examples: - Journey.Node.schedule_recurring/4","doc":"```elixir\niex> import Journey.Node\niex> graph = Journey.new_graph(\n...>       \"`schedule_recurring()` doctest graph (it issues 'reminders' every few seconds)\",\n...>       \"v1.0.0\",\n...>       [\n...>         input(:name),\n...>         schedule_recurring(\n...>           :schedule_a_reminder,\n...>           [:name],\n...>           fn _ ->\n...>             soon = System.system_time(:second) + 2\n...>             {:ok, soon}\n...>           end\n...>         ),\n...>         compute(\n...>           :send_a_reminder,\n...>           [:name, :schedule_a_reminder],\n...>           fn %{name: name} = v ->\n...>             reminder_count = Map.get(v, :send_a_reminder, 0) + 1\n...>             IO.puts(\"[#{System.system_time(:second)}] #{name}, here is your scheduled reminder # #{reminder_count}.\")\n...>             {:ok, reminder_count}\n...>           end\n...>         )\n...>       ]\n...>     )\niex> execution =\n...>     graph\n...>     |> Journey.start_execution()\n...>     |> Journey.set_value(:name, \"Mario\")\niex> execution |> Journey.values() |> Map.get(:name)\n\"Mario\"\niex> # This is only needed in a test, to simulate the background processing that happens in non-tests automatically.\niex> background_sweeps_task = Journey.Scheduler.Background.Periodic.start_background_sweeps_in_test(execution.id)\niex> # Wait for initial reminders\niex> {:ok, count1} = Journey.get_value(execution, :send_a_reminder, wait_any: true)\niex> count1 >= 1\ntrue\niex> # Wait for more reminders to verify recurring behavior\niex> execution = Journey.load(execution)\niex> {:ok, count2} = Journey.get_value(execution, :send_a_reminder, wait_new: true)\niex> count2 > count1\ntrue\niex> execution = Journey.load(execution)\niex> {:ok, count3} = Journey.get_value(execution, :send_a_reminder, wait_new: true)\niex> count3 > count2\ntrue\niex> Journey.Scheduler.Background.Periodic.stop_background_sweeps_in_test(background_sweeps_task)\n\n```","ref":"Journey.Node.html#schedule_recurring/4-examples"},{"type":"function","title":"Return Values - Journey.Node.schedule_recurring/4","doc":"The f_compute function must return `{:ok, value}` or `{:error, reason}`. Note that atoms \nin the returned `value` and `reason` will be converted to strings when persisted.","ref":"Journey.Node.html#schedule_recurring/4-return-values"},{"type":"module","title":"Journey.Node.Conditions","doc":"This module contains helper functions for use when defining upstream dependencies for `compute` modules.","ref":"Journey.Node.Conditions.html"},{"type":"function","title":"Journey.Node.Conditions.false?/1","doc":"This is a helper function provided for use in `unblocked_when` conditions.\nThis function checks if the upstream node's value is `false`.","ref":"Journey.Node.Conditions.html#false?/1"},{"type":"function","title":"Examples - Journey.Node.Conditions.false?/1","doc":"```elixir\niex> import Journey.Node\niex> import Journey.Node.Conditions\niex> import Journey.Node.UpstreamDependencies\niex> graph = Journey.new_graph(\n...>   \"umbrella forecast graph, doctest for false?\",\n...>   \"v1.0.0\",\n...>   [\n...>     input(:it_will_rain_tomorrow),\n...>     compute(\n...>       :todays_preparation,\n...>       unblocked_when(:it_will_rain_tomorrow, &false?/1),\n...>       fn %{it_will_rain_tomorrow: false} -> {:ok, \"prepare my bike\"} end\n...>     )\n...>   ]\n...> )\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :it_will_rain_tomorrow, false)\niex> Journey.get_value(execution, :todays_preparation, wait_any: true)\n{:ok, \"prepare my bike\"}\niex> execution = Journey.set_value(execution, :it_will_rain_tomorrow, true)\niex> Journey.get_value(execution, :todays_preparation)\n{:error, :not_set}\n\n```","ref":"Journey.Node.Conditions.html#false?/1-examples"},{"type":"function","title":"Journey.Node.Conditions.provided?/1","doc":"This is a helper function provided for use in `unblocked_when` conditions.\nThis function checks if the supplied node has a value.\nFor \"scheduled\" types of nodes (`schedule_once`, `schedule_recurring`) it also checks that the scheduled time has come).","ref":"Journey.Node.Conditions.html#provided?/1"},{"type":"function","title":"Examples - Journey.Node.Conditions.provided?/1","doc":"```elixir\niex> import Journey.Node\niex> import Journey.Node.Conditions\niex> import Journey.Node.UpstreamDependencies\niex> graph = Journey.new_graph(\n...>   \"greeting workflow, doctest for provided?\",\n...>   \"v1.0.0\",\n...>   [\n...>     input(:name),\n...>     compute(\n...>       :greeting,\n...>       unblocked_when(:name, &provided?/1),\n...>       fn %{name: name} -> {:ok, \"Hello, #{name}!\"} end\n...>     )\n...>   ]\n...> )\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :name, \"Alice\")\niex> Journey.get_value(execution, :greeting, wait_any: true)\n{:ok, \"Hello, Alice!\"}\n```","ref":"Journey.Node.Conditions.html#provided?/1-examples"},{"type":"function","title":"Journey.Node.Conditions.true?/1","doc":"This is a helper function provided for use in `unblocked_when` conditions.\nThis function checks if the upstream node's value is `true`.","ref":"Journey.Node.Conditions.html#true?/1"},{"type":"function","title":"Examples - Journey.Node.Conditions.true?/1","doc":"```elixir\niex> import Journey.Node\niex> import Journey.Node.Conditions\niex> import Journey.Node.UpstreamDependencies\niex> graph = Journey.new_graph(\n...>   \"umbrella forecast graph, doctest for true?\",\n...>   \"v1.0.0\",\n...>   [\n...>     input(:it_will_rain_tomorrow),\n...>     compute(\n...>       :umbrella,\n...>       unblocked_when(:it_will_rain_tomorrow, &true?/1),\n...>       fn %{it_will_rain_tomorrow: true} -> {:ok, \"need to pack my umbrella\"} end\n...>     )\n...>   ]\n...> )\niex> execution = Journey.start_execution(graph)\niex> execution = Journey.set_value(execution, :it_will_rain_tomorrow, true)\niex> Journey.get_value(execution, :umbrella, wait_any: true)\n{:ok, \"need to pack my umbrella\"}\niex> execution = Journey.set_value(execution, :it_will_rain_tomorrow, false)\niex> Journey.get_value(execution, :umbrella)\n{:error, :not_set}\n\n```","ref":"Journey.Node.Conditions.html#true?/1-examples"},{"type":"module","title":"Journey.Node.UpstreamDependencies","doc":"","ref":"Journey.Node.UpstreamDependencies.html"},{"type":"function","title":"Journey.Node.UpstreamDependencies.unblocked_when/1","doc":"","ref":"Journey.Node.UpstreamDependencies.html#unblocked_when/1"},{"type":"function","title":"Journey.Node.UpstreamDependencies.unblocked_when/2","doc":"This function is used to define the conditions under which a node is unblocked. It is intended to be used in the `gated_by` option of a node. The function takes a list of required upstream nodes and returns a predicate tree that can be used to check if the node is unblocked.\n\nThe predicate tree can be a single node name, a function that takes a value node and returns a boolean, or a combination of these using `:and`, `:or`, and `:not` operations.\n\nThe function also supports nested predicate trees, allowing for complex conditions to be defined.\n\nExamples:\n\n```elixir\niex> import Journey.Node\niex> import Journey.Node.Conditions\niex> import Journey.Node.UpstreamDependencies\niex> _graph =\n...>   Journey.new_graph(\n...>     \"horoscope workflow - unblocked_when doctest\",\n...>     \"v1.0.0\",\n...>     [\n...>       input(:first_name),\n...>       input(:birth_day),\n...>       input(:birth_month),\n...>       input(:suspended),\n...>       compute(\n...>         :zodiac_sign,\n...>         # Computes itself once :birth_month and :birth_day have been provided:\n...>         [:birth_month, :birth_day],\n...>         fn %{birth_month: _birth_month, birth_day: _birth_day} ->\n...>           # Everyone is a Taurus. ;)\n...>           {:ok, \"Taurus\"}\n...>         end\n...>       ),\n...>       compute(\n...>         :horoscope,\n...>         # Computes itself once :first_name and :zodiac_sign are in place, and if not suspended.\n...>         unblocked_when({\n...>           :and,\n...>           [\n...>             {:first_name, &provided?/1},\n...>             {:zodiac_sign, &provided?/1},\n...>             {:suspended, fn suspended -> suspended.node_value != true end}\n...>           ]\n...>         }),\n...>         fn %{first_name: name, zodiac_sign: zodiac_sign} ->\n...>           {:ok, \"ðŸªs await, #{zodiac_sign} #{name}!\"}\n...>         end\n...>       )\n...>     ]\n...>   )\niex>\n```","ref":"Journey.Node.UpstreamDependencies.html#unblocked_when/2"},{"type":"module","title":"Journey.Tools","doc":"This module contains utility functions for the Journey library.","ref":"Journey.Tools.html"},{"type":"function","title":"Journey.Tools.computation_state/2","doc":"Returns the current state of a computation node.\n\nReturns the state of the most recent computation attempt for the given node.\nIf no computation has been attempted yet, returns `:not_set`.\nFor input nodes (non-compute nodes), returns `:not_compute_node`.","ref":"Journey.Tools.html#computation_state/2"},{"type":"function","title":"Parameters - Journey.Tools.computation_state/2","doc":"- `execution_id` - The ID of the execution to check\n- `node_name` - The atom name of the node to check","ref":"Journey.Tools.html#computation_state/2-parameters"},{"type":"function","title":"Returns - Journey.Tools.computation_state/2","doc":"- `:not_set` - No computation has been attempted yet\n- `:computing` - Currently computing\n- `:success` - Computation completed successfully\n- `:failed` - Computation failed\n- `:abandoned` - Computation was abandoned\n- `:cancelled` - Computation was cancelled\n- `:not_compute_node` - The node is an input node, not a computation","ref":"Journey.Tools.html#computation_state/2-returns"},{"type":"function","title":"Examples - Journey.Tools.computation_state/2","doc":"iex> import Journey.Node\n    iex> graph = Journey.new_graph(\"computation_state doctest graph\", \"v1.0.0\", [\n    ...>   input(:value),\n    ...>   compute(:double, [:value], fn %{value: v} -> {:ok, v * 2} end)\n    ...> ])\n    iex> execution = Journey.start_execution(graph)\n    iex> Journey.Tools.computation_state(execution.id, :double)\n    :not_set\n    iex> Journey.Tools.computation_state(execution.id, :value)\n    :not_compute_node\n    iex> execution = Journey.set_value(execution, :value, 5)\n    iex> {:ok, _result} = Journey.get_value(execution, :double, wait_new: true)\n    iex> Journey.Tools.computation_state(execution.id, :double)\n    :success","ref":"Journey.Tools.html#computation_state/2-examples"},{"type":"function","title":"Journey.Tools.computation_state_to_text/1","doc":"Converts a computation state atom to human-readable text with a visual symbol.\n\nReturns a formatted string with an appropriate symbol and the state atom\nfor each computation state, following the pattern used in other Journey\ntext formatting functions.","ref":"Journey.Tools.html#computation_state_to_text/1"},{"type":"function","title":"Parameters - Journey.Tools.computation_state_to_text/1","doc":"- `state` - The computation state atom returned by `computation_state/2`","ref":"Journey.Tools.html#computation_state_to_text/1-parameters"},{"type":"function","title":"Returns - Journey.Tools.computation_state_to_text/1","doc":"A string with symbol and the state atom.","ref":"Journey.Tools.html#computation_state_to_text/1-returns"},{"type":"function","title":"State Representations - Journey.Tools.computation_state_to_text/1","doc":"- `:not_set` - \"â¬œ :not_set (not yet attempted)\"\n- `:computing` - \"â³ :computing\"\n- `:success` - \"âœ… :success\"\n- `:failed` - \"âŒ :failed\"\n- `:abandoned` - \"â“ :abandoned\"\n- `:cancelled` - \"ðŸ›‘ :cancelled\"\n- `:not_compute_node` - \"ðŸ“ :not_compute_node\"","ref":"Journey.Tools.html#computation_state_to_text/1-state-representations"},{"type":"function","title":"Examples - Journey.Tools.computation_state_to_text/1","doc":"iex> Journey.Tools.computation_state_to_text(:success)\n    \"âœ… :success\"\n\n    iex> Journey.Tools.computation_state_to_text(:computing)\n    \"â³ :computing\"\n\n    iex> Journey.Tools.computation_state_to_text(:not_set)\n    \"â¬œ :not_set (not yet attempted)\"","ref":"Journey.Tools.html#computation_state_to_text/1-examples"},{"type":"function","title":"Journey.Tools.computation_status_as_text/2","doc":"Shows the status and dependencies for a single computation node.\n\nProvides a focused view of one specific computation node's status and dependencies,\nsimilar to the computation sections in summarize_as_text/1 but for just one node.","ref":"Journey.Tools.html#computation_status_as_text/2"},{"type":"function","title":"Parameters - Journey.Tools.computation_status_as_text/2","doc":"- `execution_id` - The ID of the execution to analyze\n- `node_name` - The atom name of the computation node to check","ref":"Journey.Tools.html#computation_status_as_text/2-parameters"},{"type":"function","title":"Returns - Journey.Tools.computation_status_as_text/2","doc":"A string showing the node's current status and dependencies.\n\nFor completed computations, shows the result with inputs used:\n\n    :send_follow_up (CMPTA5MDJHVXRMG54150EGX): âœ… :success | :compute | rev 4\n    inputs used:\n       :user_applied (rev 0)\n       :card_mailed (rev 0)\n\nFor outstanding computations, shows the dependency tree:\n\n    :send_weekly_reminder (CMPTA5MDJHVXRMG54150EGX): â¬œ :not_set (not yet attempted) | :compute\n         :and\n          â”œâ”€ ðŸ›‘ :subscribe_weekly | &true?/1\n          â”œâ”€ ðŸ›‘ :weekly_reminder_schedule | &provided?/1\n          â””â”€ âœ… :email_address | &provided?/1 | rev 2\n\nFor input nodes (non-compute nodes), returns an appropriate message.","ref":"Journey.Tools.html#computation_status_as_text/2-returns"},{"type":"function","title":"Examples - Journey.Tools.computation_status_as_text/2","doc":"iex> import Journey.Node\n    iex> graph = Journey.new_graph(\"computation_status_as_text doctest\", \"v1.0.0\", [\n    ...>   input(:value),\n    ...>   compute(:double, [:value], fn %{value: v} -> {:ok, v * 2} end)\n    ...> ])\n    iex> execution = Journey.start_execution(graph)\n    iex> Journey.Tools.computation_status_as_text(execution.id, :double)\n    \":double: â¬œ :not_set (not yet attempted) | :compute\\n       âœ… :value | &is_set/1\"\n\n    iex> import Journey.Node\n    iex> graph = Journey.new_graph(\"computation_status_as_text completed doctest\", \"v1.0.0\", [\n    ...>   input(:value),\n    ...>   compute(:triple, [:value], fn %{value: v} -> {:ok, v * 3} end)\n    ...> ])\n    iex> execution = Journey.start_execution(graph)\n    iex> execution = Journey.set_value(execution, :value, 5)\n    iex> {:ok, _} = Journey.get_value(execution, :triple, wait_new: true)\n    iex> result = Journey.Tools.computation_status_as_text(execution.id, :triple)\n    iex> result =~ \":triple\"\n    true\n    iex> result =~ \"âœ… :success\"\n    true\n    iex> result =~ \"inputs used\"\n    true","ref":"Journey.Tools.html#computation_status_as_text/2-examples"},{"type":"function","title":"Journey.Tools.generate_mermaid_graph/2","doc":"Generates a Mermaid diagram representation of a Journey graph.\n\nConverts a graph into Mermaid syntax for visualization. By default returns only\nthe flow diagram without legend or timestamp.","ref":"Journey.Tools.html#generate_mermaid_graph/2"},{"type":"function","title":"Quick Example - Journey.Tools.generate_mermaid_graph/2","doc":"```elixir\n# Just the flow\nmermaid = Journey.Tools.generate_mermaid_graph(graph)\n\n# Include legend and timestamp\nmermaid = Journey.Tools.generate_mermaid_graph(graph,\n  include_legend: true,\n  include_timestamp: true\n)\n```","ref":"Journey.Tools.html#generate_mermaid_graph/2-quick-example"},{"type":"function","title":"Options - Journey.Tools.generate_mermaid_graph/2","doc":"* `:include_legend` - Include node type legend (default: `false`)\n* `:include_timestamp` - Include generation timestamp (default: `false`)","ref":"Journey.Tools.html#generate_mermaid_graph/2-options"},{"type":"function","title":"Journey.Tools.retry_computation/2","doc":"Retries a failed computation.\n\nThis function enables retrying computations that have exhausted their max_retries\nby making their previous attempts \"stale\" through upstream revision changes, then\ncreating a new computation for the scheduler to pick up.","ref":"Journey.Tools.html#retry_computation/2"},{"type":"function","title":"Parameters - Journey.Tools.retry_computation/2","doc":"- `execution_id` - The ID of the execution containing the failed computation\n- `computation_node_name` - The atom name of the computation node to retry","ref":"Journey.Tools.html#retry_computation/2-parameters"},{"type":"function","title":"Returns - Journey.Tools.retry_computation/2","doc":"The updated execution struct","ref":"Journey.Tools.html#retry_computation/2-returns"},{"type":"function","title":"Example - Journey.Tools.retry_computation/2","doc":"iex> Journey.Tools.retry_computation(\"EXEC123\", :email_horoscope)\n    %Journey.Persistence.Schema.Execution{...}","ref":"Journey.Tools.html#retry_computation/2-example"},{"type":"function","title":"How It Works - Journey.Tools.retry_computation/2","doc":"1. Finds upstream dependencies that are currently satisfied\n2. Increments the revision of the first available upstream node\n3. Creates a new :not_set computation for the scheduler to pick up\n4. Previous failed attempts become \"stale\" in the retry counting logic\n5. The scheduler can now execute the new computation attempt","ref":"Journey.Tools.html#retry_computation/2-how-it-works"},{"type":"function","title":"Journey.Tools.summarize/1","doc":"Generates a human-readable text summary of an execution's current state.\n\n**This function is deprecated.** Use `summarize_as_text/1` instead.","ref":"Journey.Tools.html#summarize/1"},{"type":"function","title":"Parameters - Journey.Tools.summarize/1","doc":"- `execution_id` - The ID of the execution to analyze","ref":"Journey.Tools.html#summarize/1-parameters"},{"type":"function","title":"Returns - Journey.Tools.summarize/1","doc":"A formatted string with the complete execution state summary.","ref":"Journey.Tools.html#summarize/1-returns"},{"type":"function","title":"Journey.Tools.summarize_as_data/1","doc":"Generates structured data about an execution's current state.\n\nReturns a map containing:\n- Execution metadata (ID, graph, timestamps, duration, revision, archived status)\n- Values categorized as set/not_set with their details\n- Computations categorized as completed/outstanding with dependency info","ref":"Journey.Tools.html#summarize_as_data/1"},{"type":"function","title":"Example - Journey.Tools.summarize_as_data/1","doc":"iex> Journey.Tools.summarize_as_data(\"EXEC07B2H0H7J1LTAE0VJDAL\")\n    %{\n      execution_id: \"EXEC07B2H0H7J1LTAE0VJDAL\",\n      graph_name: \"g1\",\n      graph_version: \"v1\",\n      archived_at: nil,\n      created_at: 1723656196,\n      updated_at: 1723656210,\n      duration_seconds: 14,\n      revision: 7,\n      values: %{\n        set: [...],\n        not_set: [...]\n      },\n      computations: %{\n        completed: [...],\n        outstanding: [...]\n      }\n    }","ref":"Journey.Tools.html#summarize_as_data/1-example"},{"type":"function","title":"Parameters - Journey.Tools.summarize_as_data/1","doc":"- `execution_id` - The ID of the execution to analyze","ref":"Journey.Tools.html#summarize_as_data/1-parameters"},{"type":"function","title":"Returns - Journey.Tools.summarize_as_data/1","doc":"A structured map with execution state data.\n\nUse `summarize_as_text/1` to get execution summary as text.","ref":"Journey.Tools.html#summarize_as_data/1-returns"},{"type":"function","title":"Journey.Tools.summarize_as_text/1","doc":"Generates a human-readable text summary of an execution's current state.","ref":"Journey.Tools.html#summarize_as_text/1"},{"type":"function","title":"Example - Journey.Tools.summarize_as_text/1","doc":"iex> Journey.Tools.summarize_as_text(\"EXEC07B2H0H7J1LTAE0VJDAL\") |> IO.puts()\n    Execution summary:\n    - ID: 'EXEC07B2H0H7J1LTAE0VJDAL'\n    - Graph: 'g1' | 'v1'\n    ...\n    :ok","ref":"Journey.Tools.html#summarize_as_text/1-example"},{"type":"function","title":"Parameters - Journey.Tools.summarize_as_text/1","doc":"- `execution_id` - The ID of the execution to analyze","ref":"Journey.Tools.html#summarize_as_text/1-parameters"},{"type":"function","title":"Returns - Journey.Tools.summarize_as_text/1","doc":"A formatted string with the complete execution state summary.\n\nUse `summarize_as_data/1` to get execution summary as data.","ref":"Journey.Tools.html#summarize_as_text/1-returns"},{"type":"function","title":"Journey.Tools.what_am_i_waiting_for/2","doc":"Shows the status of upstream dependencies for a computation node.\n\nLists each dependency with a checkmark (âœ…) if satisfied or a stop sign (ðŸ›‘) if not.\nUseful for debugging to see which dependencies are met and which are still blocking.","ref":"Journey.Tools.html#what_am_i_waiting_for/2"},{"type":"function","title":"Parameters - Journey.Tools.what_am_i_waiting_for/2","doc":"- `execution_id` - The ID of the execution to analyze\n- `computation_node_name` - The atom name of the computation node to check","ref":"Journey.Tools.html#what_am_i_waiting_for/2-parameters"},{"type":"function","title":"Returns - Journey.Tools.what_am_i_waiting_for/2","doc":"A string showing the readiness status with checkmarks for met conditions and\nstop signs for unmet conditions.","ref":"Journey.Tools.html#what_am_i_waiting_for/2-returns"},{"type":"function","title":"Example - Journey.Tools.what_am_i_waiting_for/2","doc":"iex> import Journey.Node\n    iex> graph = Journey.new_graph(\"what_am_i_waiting_for test graph Elixir.Journey.Tools\", \"v1.0.0\", [\n    ...>   input(:name),\n    ...>   input(:title),\n    ...>   compute(:greeting, [:name, :title], fn %{name: name, title: title} ->\n    ...>     {:ok, \"Hello, #{title} #{name}!\"}\n    ...>   end)\n    ...> ])\n    iex> {:ok, execution} = Journey.start_execution(graph)\n    iex> Journey.Tools.what_am_i_waiting_for(execution.id, :greeting) |> IO.puts()\n    ðŸ›‘ :name | &is_set/1\n    ðŸ›‘ :title | &is_set/1\n    :ok\n    iex> {:ok, execution} = Journey.set_value(execution, :name, \"Alice\")\n    iex> Journey.Tools.what_am_i_waiting_for(execution.id, :greeting) |> IO.puts()\n    âœ… :name | &is_set/1 | rev 1\n    ðŸ›‘ :title | &is_set/1\n    :ok\n    iex> {:ok, execution} = Journey.set_value(execution, :title, \"Dr.\")\n    iex> {:ok, _greeting_value} = Journey.get_value(execution, :greeting, wait_new: true)\n    iex> Journey.Tools.what_am_i_waiting_for(execution.id, :greeting) |> IO.puts()\n    âœ… :name | &is_set/1 | rev 1\n    âœ… :title | &is_set/1 | rev 2\n    :ok","ref":"Journey.Tools.html#what_am_i_waiting_for/2-example"},{"type":"module","title":"UselessMachine","doc":"This module ([lib/examples/useless_machines.ex](https://github.com/markmark206/journey/blob/main/lib/examples/useless_machine.ex)) contains an example of building a Useless Machine using Journey.\n\nHere is an example of running the useless Machine:\n\n```elixir\niex> graph = UselessMachine.graph()\niex> execution = Journey.start_execution(graph)\niex> Journey.get_value(execution, :switch)\n{:error, :not_set}\niex> Journey.get_value(execution, :paw)\n{:error, :not_set}\niex> Journey.set_value(execution, :switch, \"on\")\niex> # updating switch triggers :paw\niex> Journey.get_value(execution, :paw, wait_any: true)\n{:ok, \"updated :switch\"}\niex> # :paw set switch back to \"off\"\niex> Journey.get_value(execution, :switch, wait_any: true)\n{:ok, \"off\"}\n```","ref":"UselessMachine.html"},{"type":"function","title":"UselessMachine.graph/0","doc":"This function defines the graph for the Useless Machine.\nIt starts with a switch input and mutates the state to \"off\" when the switch\nis toggled, simulating the behavior of a Useless Machine.","ref":"UselessMachine.html#graph/0"},{"type":"function","title":"UselessMachine.lol_no/1","doc":"This function simulates the paw's response when the switch is toggled.\nIt prints a message and mutates the state of the :switch node to \"off\".","ref":"UselessMachine.html#lol_no/1"},{"type":"extras","title":"Journey","doc":"# Journey\n\nJourney is an Elixir library for building and executing computation graphs, with built-in persistence, reliability, and scalability.\n\nDefine your application workflows as dependency graphs where user inputs automatically trigger computations in the correct order, with all state persisted to PostgreSQL.\n\nExecutions of the graph survive crashes, redeploys, page reloads, while scaling naturally with your application - no additional infrastructure or cloud service$ required.\n\nYour application can perform durable, short or long-running executions, with retries, scalability, dependency tracking, scheduling and analytics.\n\nJourney's primitives are simple: graph, dependencies, functions, persistence, retries, scheduling. Together, they help you build rich, scalable, reliable functionality with simple, well-structured and easy-to-understand code, quickly.","ref":"readme.html"},{"type":"extras","title":"Installation and Configuration - Journey","doc":"To use Journey in your application, you will need to install the package, configure its db, optionally configure its logging, and tell it about the graphs you want Journey to be aware of.\n\n1. The package can be installed by adding `journey` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:journey, \"~> 0.10\"}\n  ]\nend\n```\n\n2. Journey uses Postgres DB for persistence. Add Journey Postgres DB to your project's configuration.\n\nAlongside your app's Repo configuration, add Journey's. For example, if you want to use Journey in your Phoenix application, you might do something like:\n\n`config/test.exs`:\n```elixir\nconfig :journey, Journey.Repo,\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\",\n  database: \"demo_journey_test#{System.get_env(\"MIX_TEST_PARTITION\")}\",\n  pool_size: System.schedulers_online() * 2\n```\n\n`config/dev.exs`:\n```elixir\nconfig :journey, Journey.Repo,\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\",\n  database: \"demo_journey_dev\",\n  stacktrace: true,\n  show_sensitive_data_on_connection_error: true,\n  pool_size: 10,\n  log: false\n```\n\n`config/runtime.exs`:\n```elixir\nif config_env() == :prod do\n  ...\n  database_journey_url =\n    System.get_env(\"DATABASE_JOURNEY_URL\") ||\n      raise \"\"\"\n      environment variable DATABASE_JOURNEY_URL is missing.\n      For example: ecto://USER:PASS@HOST/DATABASE\n      \"\"\"\n\n  config :journey, Journey.Repo,\n    # ssl: true,\n    url: database_journey_url,\n    pool_size: String.to_integer(System.get_env(\"POOL_SIZE_JOURNEY\") || \"10\"),\n    socket_options: maybe_ipv6\n  ...\nend\n```\n\n3. Configure the level of logging you want to see from Journey\n\nExample:\n`config/config.exs`:\n```elixir\nconfig :journey, log_level: :warning\n```\n\n4. Tell Journey which graphs it should know about:\n\n`config/config.exs`:\n```elixir\nconfig :journey, :graphs, [\n  # This is just an example graph that ships with Journey.\n  &Journey.Examples.CreditCardApplication.graph/0,\n\n  # When you define functions that create graphs in your application, add them here.\n  ...\n]\n```","ref":"readme.html#installation-and-configuration"},{"type":"extras","title":"Questions / Comments / Issues - Journey","doc":"To get in touch, report an issue, or ask a question, please create a github issue: https://github.com/markmark206/journey/issues","ref":"readme.html#questions-comments-issues"},{"type":"extras","title":"Full Documentation - Journey","doc":"Documentation can be found at  .","ref":"readme.html#full-documentation"},{"type":"extras","title":"Journey License","doc":"# Journey License\n\nCopyright (c) 2021-2025 Mark Markaryan\n\nJourney is dual-licensed to support individuals and small teams while ensuring that commercial use contributes to its ongoing development.\n\n---","ref":"license.html"},{"type":"extras","title":"0. TL;DR (Informal Summary) - Journey License","doc":"Journey is free to use for your project, if your Entity generates less than $10k/month in total revenue.\n\nFor all other uses, please purchase a build key: [https://gojourney.dev](https://gojourney.dev).\n\n---","ref":"license.html#0-tl-dr-informal-summary"},{"type":"extras","title":"1. Definitions - Journey License","doc":"- **\"Journey\"** refers to the software package named `journey`, including all code, documentation, and related materials.\n- **\"Use\"** means installing, copying, modifying, or executing Journey.\n- **\"Commercial Use\"** means any use of Journey in connection with a product, service, or business activity intended for or resulting in commercial advantage or monetary compensation.\n- **\"Entity\"** means any company, organization, or group of individuals working together in a coordinated business capacity, including all subsidiaries, parent companies, and affiliates under common control (directly or indirectly owning 50% or more voting interest).\n- **\"Project\"** means a distinct software application, service, or system that incorporates Journey, whether for internal operations, customer-facing services, or any other business purpose.\n\n---","ref":"license.html#1-definitions"},{"type":"extras","title":"2. Grant of License (Permitted Use) - Journey License","doc":"You may use Journey freely if your Entity generates less than $10,000 USD in total monthly revenue.\n\nFor Entities generating at least $10,000 USD in total monthly revenue, each Project using Journey requires a separate commercial build key. Please purchase a build key: [https://gojourney.dev](https://gojourney.dev)\n\n---","ref":"license.html#2-grant-of-license-permitted-use"},{"type":"extras","title":"3. Commercial License Required - Journey License","doc":"If your Entity generates at least $10,000 USD in total monthly revenue, you must obtain a separate commercial build key for each Project that uses Journey.\n\nThis includes internal business applications such as employee tools, operational systems, data processing applications, and administrative systems.\n\nTo purchase a commercial build key, please visit: [https://gojourney.dev](https://gojourney.dev)\n\nIf you believe your use of Journey requires a commercial license, you may continue using it for up to **30 days** while you evaluate licensing terms, without a build key or with a free \"Small Project\" build key. Continued use beyond this period without a valid commercial build key may violate this agreement.\n\n---","ref":"license.html#3-commercial-license-required"},{"type":"extras","title":"4. Restrictions - Journey License","doc":"- You may not sublicense, redistribute, or repackage Journey (modified or unmodified) as part of a paid product, developer tool, or commercial service without a commercial license.\n- You may not remove or alter licensing notices or attribution in the source code.\n\n---","ref":"license.html#4-restrictions"},{"type":"extras","title":"5. Warranty Disclaimer - Journey License","doc":"JOURNEY IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.\n\nIN NO EVENT SHALL THE AUTHOR OR COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY ARISING FROM THE USE OF JOURNEY.\n\n---","ref":"license.html#5-warranty-disclaimer"},{"type":"extras","title":"6. Not Open Source (OSI) - Journey License","doc":"This license does **not** comply with the Open Source Definition as defined by the [Open Source Initiative](https://opensource.org/osd). Journey is **source-available** software.\n\n---","ref":"license.html#6-not-open-source-osi"},{"type":"extras","title":"7. Governing Law - Journey License","doc":"This license shall be governed by and construed in accordance with the laws of the State of Washington, USA, without regard to conflict of law principles.\n\nAny legal action arising from this license shall be brought exclusively in the state or federal courts located in King County, Washington.\n\n\n---\n\nâ€“ Mark Markaryan\n\n[github.com/markmark206/journey](https://github.com/markmark206/journey)\n\n[gojourney.dev](https://gojourney.dev)","ref":"license.html#7-governing-law"},{"type":"extras","title":"Changelog","doc":"# Changelog","ref":"changelog.html"},{"type":"extras","title":"v0.10.31 - Changelog","doc":"- Expanding possible versions of [`ecto`](https://hexdocs.pm/ecto) and [`ecto_sql`](https://hexdocs.pm/ecto_sql) to include `3.13`, in addition to `3.12`.\n- Hardening handling of computations that didn't complete due to various conditions (infrastructure reboots, crashes, redeployments, failures).","ref":"changelog.html#v0-10-31"},{"type":"extras","title":"Updating Graphs","doc":"# Updating Graphs","ref":"migration_strategy.html"},{"type":"extras","title":"I need to change my graph. How? - Updating Graphs","doc":"If the change **does not break** the flow, simply make the change, test, and deploy it.\n\nIf the change **breaks** the flow, create a new graph, with a new name and/or version. Switch your code to create executions of the new graph instead of the old graph, and new executions will follow the new flow.\n\nAs long as the old graph continues to be registered, old executions will continue to navigate the flow defined in the old graph.\n\nExamples of changes that might **break** the flow:\n* Changing upstream dependencies on pre-existing computation nodes.\n* Removing or renaming a node.\n\nAnything that would have the current executions go \"Huh? Now what do I do??!?\" is likely to be a breaking change, that would require creating a new graph.\n\nHowever, if you don't care about the state of current or old executions, you can archive them all (`Journey.list_executions(graph_name: graph.name, graph_version: graph.version) |> Enum.each(fn e -> Journey.archive(e.id) end)`), and simply change your existing graph, even if changes are major.","ref":"migration_strategy.html#i-need-to-change-my-graph-how"},{"type":"extras","title":"Examples - Updating Graphs","doc":"","ref":"migration_strategy.html#examples"},{"type":"extras","title":"A minor change (no new graph needed) - Updating Graphs","doc":"Updating this graph\n\n```elixir\ngraph = Journey.new_graph(\n  \"zodiac\",\n  \"v1.0.0\",\n  [\n    input(:name),\n    input(:birthday),\n    compute(:zodiac_sign, [:name, :birthday], &compute_zodiac/1)\n  ]\n)\n```\n\nwith a couple of extra independent or downstream nodes is **not a breaking change**, and it does not require a new graph definition:\n\n```elixir\ngraph = Journey.new_graph(\n  \"zodiac\",\n  \"v1.0.0\",\n  [\n    input(:name),\n    input(:birthday),\n    # new input node:\n    input(:pet_preference),\n    compute(:zodiac_sign, [:name, :birthday], &compute_zodiac/1),\n    # new computation:\n    compute(:horoscope, [:zodiac_sign, :pet_preference], &compute_horoscope/1)\n  ]\n)\n```\n\nIf a graph was updated to include new nodes, the executions of this graph will be upgraded to include those new nodes when they are loaded.","ref":"migration_strategy.html#a-minor-change-no-new-graph-needed"},{"type":"extras","title":"A major change (need a new graph) - Updating Graphs","doc":"If you need to make `:zodiac_sign` dependent on having the user's credit card number (for some reason), you'll likely need a new graph (or have existing executions enter an ambiguous state).\n\n```elixir\ngraph = Journey.new_graph(\n  \"zodiac\",\n  # new version!\n  \"v2.0.0\",\n  [\n    input(:name),\n    input(:birthday),\n    # new input node:\n    input(:cc),\n    # new upstream prerequisite:\n    compute(:zodiac_sign, [:name, :birthday, :cc], &compute_zodiac/1)\n  ]\n)\n```\n\nThen make sure your configuration registers both graphs:\n\n```elixir\nconfig :journey, :graphs, [\n  &MyApp.Graphs.Zodiac.V1.graph/0,\n  &MyApp.Graphs.Zodiac.V2.graph/0\n]\n```\n\nThe strategy described here applies to evolving a graph due to changing requirements or fixing of bugs in the code or in the flow.","ref":"migration_strategy.html#a-major-change-need-a-new-graph"},{"type":"extras","title":"Building a resilient application with Journey","doc":"<!-- livebook:{\"persist_outputs\":true} -->\n\n# Building a resilient application with Journey\n\n```elixir\n# [Optional] Setting Build Key, see https://gojourney.dev/your_keys\n# (Using \"Journey Livebook Demo\" build key)\nSystem.put_env(\"JOURNEY_BUILD_KEY\", \"B27AXHMERm2Z6ehZhL49v\")\n\nMix.install(\n  [\n    {:ecto_sql, \"~> 3.10\"},\n    {:postgrex, \"~> 0.21\"},\n    {:jason, \"~> 1.4\"},\n    {:journey, \"~> 0.10\"},\n    # {:journey, path: Path.join([__DIR__, \"../..\"])},\n    {:kino_vega_lite, \"~> 0.1.11\"},\n    {:kino, \"~> 0.16.1\"}\n  ],\n  start_applications: false\n)\n\nApplication.put_env(:journey, :log_level, :warning)\n\n# Update this configuration to point to your database server\n# (to create the database, run `mix ecto.create` from the root of the repo).\nApplication.put_env(:journey, Journey.Repo,\n  database: \"journey_dev\",\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\",\n  log: false,\n  port: 5432\n)\n\nApplication.put_env(:journey, :ecto_repos, [Journey.Repo])\n\nApplication.loaded_applications()\n|> Enum.map(fn {app, _, _} -> app end)\n|> Enum.each(&Application.ensure_all_started/1)\n```","ref":"basic.html"},{"type":"extras","title":"Getting things done with Journey - Building a resilient application with Journey","doc":"This livebook shows using Journey for a ridiculously basic flow: computing the sum of two numbers, and determining whether the sum exceeds a threshold. It has two input values (`x` and `y`) and two computations (`sum` and `large_value_alert`).\n\nThis livebook shows creating a blueprint (graph) for computing the sum and large_value_alert, and then executing an instance of the blueprint to perform computations for a particular set of inputs.\n\nA few things to note:\n\n* every input value (`:x`, `:y`), or computation result (`:sum`, `:large_value_alert`) is persisted,\n* the two computations\n  * happen reliably (their functions are executed with a retry policy),\n  * are as horizontally distributed as your app is (the functions will run wherever your app runs),\n  * are proactive (`:sum` will be computed when `:x` and `:y` become available, and `:large_value_alert` will be computed when `:sum` is available).\n* executions of this flow can be as long-running as needed (milliseconds? months?), and will live through system restarts, crashes, redeployments, page reloads, etc.\n\nThese attributes â€“Â reliability, scalability, and persistence â€“ come without the need to subscribe to an online service, or ship your application's data to a third party, or to deploy any additional infrastructure. Just your application, using a package, storing data in your database, and running as it normally would.","ref":"basic.html#getting-things-done-with-journey"},{"type":"extras","title":"Define the Blueprint of the Application - Building a resilient application with Journey","doc":"Our application is very simple, given two numbers, it computes the sum, and sets an alert if the sum is \"too large\".\n\n## \"Business logic\": `f_add(x, y)`\n\n```elixir\n# The function for adding two numbers. Part of the \"business logic\" of this application.\nf_add = fn %{x: x, y: y} -> {:ok, x + y} end\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n#Function<42.81571850/1 in :erl_eval.expr/6>\n```","ref":"basic.html#define-the-blueprint-of-the-application"},{"type":"extras","title":"The flow - Building a resilient application with Journey","doc":"A journey graph is the blueprint for this application. It defines its inputs and computed values exist, their dependencies, and attaches functions to self-computing values.\n\n```elixir\nimport Journey.Node\nimport Journey.Node.Conditions\nimport Journey.Node.UpstreamDependencies\n\ngraph = Journey.new_graph(\n  # graph name.\n  \"g1\",\n  # graph version.\n  \"v1\",\n  # graph nodes.\n  [\n    input(:x),\n    input(:y),\n    # the `:sum` computation is waiting on :x and :y.   \n    compute(:sum, [:x, :y], f_add),\n    compute(\n      :large_value_alert, \n      unblocked_when(\n        :sum, \n        fn sum_node -> sum_node.set_time != nil and sum_node.node_value > 40 end\n      ),\n      fn _ -> {:ok, \"ðŸš¨\"} end\n    ),\n  ]\n)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%Journey.Graph{\n  name: \"g1\",\n  version: \"v1\",\n  nodes: [\n    %Journey.Graph.Input{name: :execution_id, type: :input},\n    %Journey.Graph.Input{name: :last_updated_at, type: :input},\n    %Journey.Graph.Input{name: :x, type: :input},\n    %Journey.Graph.Input{name: :y, type: :input},\n    %Journey.Graph.Step{\n      name: :sum,\n      gated_by: [:x, :y],\n      f_compute: #Function<42.81571850/1 in :erl_eval.expr/6>,\n      f_on_save: nil,\n      type: :compute,\n      mutates: nil,\n      max_retries: 3,\n      abandon_after_seconds: 60\n    },\n    %Journey.Graph.Step{\n      name: :large_value_alert,\n      gated_by: {:sum, #Function<42.81571850/1 in :erl_eval.expr/6>},\n      f_compute: #Function<42.81571850/1 in :erl_eval.expr/6>,\n      f_on_save: nil,\n      type: :compute,\n      mutates: nil,\n      max_retries: 3,\n      abandon_after_seconds: 60\n    }\n  ]\n}\n```","ref":"basic.html#the-flow"},{"type":"extras","title":"Flow, visualized - Building a resilient application with Journey","doc":"Here is the visual â€“Â Mermaid â€“Â representation of the graph that we have just defined.\n\nYou can see the two input values (`:x`, `:y`), the two computations (`:sum`,`:large_value_alert`), and their dependencies.\n\nIt also shows two system values, `:execution_id` and `:last_updated_at`, which are maintained by the runtime.\n\n```elixir\ngraph\n|> Journey.Tools.generate_mermaid_graph()\n|> Kino.Mermaid.new()\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```mermaid\ngraph TD\n    %% Graph\n    subgraph Graph[\"ðŸ§© 'g1', version v1\"]\n        execution_id[execution_id]\n        last_updated_at[last_updated_at]\n        x[x]\n        y[y]\n        sum[\"sum (anonymous fn)\"]\n        large_value_alert[\"large_value_alert (anonymous fn)\"]\n\n        x -->  sum\n        y -->  sum\n        sum -->  large_value_alert\n    end\n\n    %% Styling\n    classDef inputNode fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000000\n    classDef computeNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000000\n    classDef scheduleNode fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000000\n    classDef mutateNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000000\n\n    %% Apply styles to actual nodes\n    class y,x,last_updated_at,execution_id inputNode\n    class large_value_alert,sum computeNode\n```","ref":"basic.html#flow-visualized"},{"type":"extras","title":"Executing instances of the blueprint - Building a resilient application with Journey","doc":"Now that we have the blueprint of the application, we can run its executions.","ref":"basic.html#executing-instances-of-the-blueprint"},{"type":"extras","title":"Starting a new execution - Building a resilient application with Journey","doc":"Here is an example of starting a new execution of the graph. If the application handles a user's visit to your website, this might happen when the user lands on the web page, and, perhaps, starts engaging with it.\n\nWe'll take a note of the id of the execution, just in case everything crashes (or if the user reloads the page, or leaves and comes back in a month) and we need to reload it later.\n\n```elixir\nexecution = Journey.start_execution(graph)\n\n# Take a note of the id of the execution, so we can reload it in case the data center reboots.\nexecution_id = execution.id\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n\"EXECLG0R2MD2JBARMVRE380L\"\n```\n\nThe new execution doesn't have much in it at this point, nothing has been set or computed, except for the two system fields.\n\n```elixir\n# No values are set, except for system-provided values.\nJourney.values_all(execution)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%{\n  sum: :not_set,\n  y: :not_set,\n  x: :not_set,\n  last_updated_at: {:set, 1755833244},\n  execution_id: {:set, \"EXECLG0R2MD2JBARMVRE380L\"},\n  large_value_alert: :not_set\n}\n```","ref":"basic.html#starting-a-new-execution"},{"type":"extras","title":"Once :x and :y are provided, :sum gets computed - Building a resilient application with Journey","doc":"The user might start supplying the data:\n\n```elixir\nexecution = Journey.set_value(execution, :x, 12); :ok\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\nBtw, if the world crashed (or got redeployed, or if the user leaves), no worries.\n\nSince we took a note of the ID of the execution, we can load the execution as soon as things are back up (or when the user comes back), and proceed as if nothing happened.\n\n```elixir\nreloaded_execution = Journey.load(execution_id)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%Journey.Persistence.Schema.Execution{\n  __meta__: #Ecto.Schema.Metadata<:loaded, \"executions\">,\n  id: \"EXECLG0R2MD2JBARMVRE380L\",\n  graph_name: \"g1\",\n  graph_version: \"v1\",\n  archived_at: nil,\n  values: [\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VALGLMD0YZDTBAD40LTX7G3\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :last_updated_at,\n      node_type: :input,\n      node_value: 1755833251,\n      set_time: 1755833251,\n      ex_revision: 1,\n      inserted_at: 1755833244,\n      updated_at: 1755833251\n    },\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VALXH5TGBT2EZ64LR26AEYX\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :x,\n      node_type: :input,\n      node_value: 12,\n      set_time: 1755833251,\n      ex_revision: 1,\n      inserted_at: 1755833244,\n      updated_at: 1755833251\n    },\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VAL5GZB3YHBG48RX2G00AYL\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :execution_id,\n      node_type: :input,\n      node_value: \"EXECLG0R2MD2JBARMVRE380L\",\n      set_time: 1755833244,\n      ex_revision: 0,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    },\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VAL3HT5MMBTHX7TXD93D2A0\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :y,\n      node_type: :input,\n      node_value: nil,\n      set_time: nil,\n      ex_revision: 0,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    },\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VALM10Z0R5VHJDA7VJL68G9\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :sum,\n      node_type: :compute,\n      node_value: nil,\n      set_time: nil,\n      ex_revision: 0,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    },\n    %Journey.Persistence.Schema.Execution.Value{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"values\">,\n      id: \"VALGJGJA9A860BB3JH59YY9\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :large_value_alert,\n      node_type: :compute,\n      node_value: nil,\n      set_time: nil,\n      ex_revision: 0,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    }\n  ],\n  computations: [\n    %Journey.Persistence.Schema.Execution.Computation{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"computations\">,\n      id: \"CMPR0Y39G6ARJYG37T4G9G3\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :sum,\n      computation_type: :compute,\n      state: :not_set,\n      ex_revision_at_start: nil,\n      ex_revision_at_completion: nil,\n      scheduled_time: nil,\n      start_time: nil,\n      completion_time: nil,\n      deadline: nil,\n      error_details: nil,\n      computed_with: nil,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    },\n    %Journey.Persistence.Schema.Execution.Computation{\n      __meta__: #Ecto.Schema.Metadata<:loaded, \"computations\">,\n      id: \"CMPZ1T53HMV6LYRA3GY7G5R\",\n      execution_id: \"EXECLG0R2MD2JBARMVRE380L\",\n      execution: #Ecto.Association.NotLoaded ,\n      node_name: :large_value_alert,\n      computation_type: :compute,\n      state: :not_set,\n      ex_revision_at_start: nil,\n      ex_revision_at_completion: nil,\n      scheduled_time: nil,\n      start_time: nil,\n      completion_time: nil,\n      deadline: nil,\n      error_details: nil,\n      computed_with: nil,\n      inserted_at: 1755833244,\n      updated_at: 1755833244\n    }\n  ],\n  revision: 1,\n  inserted_at: 1755833244,\n  updated_at: 1755833251\n}\n```\n\nThe user is supplying the other input:\n\n```elixir\nreloaded_execution = Journey.set_value(reloaded_execution, :y, 2); :ok\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\nNow that both `:x` and `:y` have been supplied, `:sum` gets computed. Here is the state attached to the execution:\n\n(Note: since `:sum` is \"small\",  `:large_value_alert` does not get set (thanks to the condition we defined in the graph for this node.)\n\n```elixir\nJourney.values_all(reloaded_execution)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%{\n  sum: {:set, 14},\n  y: {:set, 2},\n  x: {:set, 12},\n  last_updated_at: {:set, 1755833255},\n  execution_id: {:set, \"EXECLG0R2MD2JBARMVRE380L\"},\n  large_value_alert: :not_set\n}\n```\n\nCan also get specific values:\n\n```elixir\nJourney.get_value(reloaded_execution, :sum, wait_any: true)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:ok, 14}\n```\n\n```elixir\nJourney.get_value(reloaded_execution, :large_value_alert)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:error, :not_set}\n```","ref":"basic.html#once-x-and-y-are-provided-sum-gets-computed"},{"type":"extras","title":"Bigger :x -> bigger :sum -> :large_value_alert ðŸš¨!! - Building a resilient application with Journey","doc":"If an input value changes, the downstream nodes get re-evaluated.\n\n```elixir\nreloaded_execution = Journey.set_value(reloaded_execution, :x, 133); :ok\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\n\"no worries, here is the updated sum\"\n\n```elixir\nJourney.get_value(reloaded_execution, :sum, wait_new: true)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:ok, 135}\n```\n\nThe updated `:x` pushes `:sum` over the threshold that triggers `:large_value_alert`:\n\n```elixir\nJourney.get_value(reloaded_execution, :large_value_alert)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:ok, \"ðŸš¨\"}\n```\n\n```elixir\nreloaded_execution = Journey.set_value(reloaded_execution, :x, 1); :ok\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\n```elixir\nJourney.get_value(reloaded_execution, :sum, wait_new: true)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:ok, 3}\n```\n\n```elixir\nJourney.get_value(reloaded_execution, :large_value_alert)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n{:error, :not_set}\n```\n\nThis basic computation happened with persistence, resiliency, and scalability.","ref":"basic.html#bigger-x-bigger-sum-large_value_alert"},{"type":"extras","title":"Searching through executions - Building a resilient application with Journey","doc":"You can search the database for execution records, querying by specific values, with sorting, limits and pagination:\n\n```elixir\nJourney.list_executions(\n  graph_name: graph.name,\n  graph_version: graph.version,\n  order_by_execution_fields: [:inserted_at],\n  filter_by: [{:sum, :gt, 2}, {:x, :lt, 10}],\n  offset: 0,\n  limit: 10\n)\n|> Enum.map(fn e ->\n  Journey.values(e)\nend)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n[\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755826416, execution_id: \"EXECV9Z60T26H0AY5BT50M6G\"},\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755827033, execution_id: \"EXECYGV60454G29YD84R2X14\"},\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755828575, execution_id: \"EXECXDGXZ01MT5915MJD984L\"},\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755830344, execution_id: \"EXECAE6861D337HRL9AY4J5Z\"},\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755831312, execution_id: \"EXEC03G5YMTV1TDVT75DTE9M\"},\n  %{sum: 3, y: 2, x: 1, last_updated_at: 1755833269, execution_id: \"EXECLG0R2MD2JBARMVRE380L\"}\n]\n```","ref":"basic.html#searching-through-executions"},{"type":"extras","title":"System Status: health, stats - Building a resilient application with Journey","doc":"You can find the stats of the system: the executions what graphs are running, how many are there, and what is happening, generally.\n\nThis is a general \"high level stats and health check\".\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nSystem stats, as a human friendly text:\n\n```elixir\nJourney.Insights.Status.status() |> Journey.Insights.Status.to_text() |> IO.puts()\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\nSystem Status: HEALTHY\nDatabase: Connected\n================================================================================\n\nGRAPHS (1 total):\n----------\nName: 'g1'\nVersion: 'v1'\nExecutions:\n- active: 6\n- archived: 0\nFirst activity: 2025-08-22T03:27:24Z\nLast activity: 2025-08-22T03:27:49Z\nComputations:\nâœ“ success: 25\nâ—¯ not_set: 7\n\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\nSystem stats, as a code-friendly data structure:\n\n```elixir\nJourney.Insights.Status.status()\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%{\n  status: :healthy,\n  graphs: [\n    %{\n      stats: %{\n        computations: %{\n          by_state: %{abandoned: 0, cancelled: 0, success: 25, failed: 0, not_set: 7, computing: 0},\n          most_recently_created: \"2025-08-22T03:27:49Z\",\n          most_recently_updated: \"2025-08-22T03:27:49Z\"\n        },\n        executions: %{\n          active: 6,\n          archived: 0,\n          most_recently_created: \"2025-08-22T03:27:24Z\",\n          most_recently_updated: \"2025-08-22T03:27:49Z\"\n        }\n      },\n      graph_name: \"g1\",\n      graph_version: \"v1\"\n    }\n  ],\n  database_connected: true\n}\n```","ref":"basic.html#system-status-health-stats"},{"type":"extras","title":"Flow Analytics: see user's progression - Building a resilient application with Journey","doc":"Since every data-setting operation touches the execution, Journey can provide stats on what is happening in the system. What percentage of users reached `:x`, what percentage of users reached `:y`, etc.\n\nIn a way, this is not unlike funnel analytics for the application defined by the graph.\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n\"Flow Analytics\" as a human-friendly text.\n\n```elixir\nJourney.Insights.FlowAnalytics.flow_analytics(graph.name, graph.version) \n|> Journey.Insights.FlowAnalytics.to_text()\n|> IO.puts()\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\nGraph: 'g1'\nVersion: 'v1'\nAnalyzed at: 2025-08-22T03:28:01.343599Z\n\nEXECUTION STATS:\n----------\nTotal executions: 6\nAverage duration: 8 seconds\nMedian duration: 1 second\n\nNODE STATS (3 nodes):\n----------\nNode Name: 'sum'\nType: compute\nReached by: 6 executions (100.0%)\nAverage time to reach: 8 seconds\nFlow ends here: 0 executions (0.0% of all, 0.0% of reached)\n\nNode Name: 'x'\nType: input\nReached by: 6 executions (100.0%)\nAverage time to reach: 8 seconds\nFlow ends here: 0 executions (0.0% of all, 0.0% of reached)\n\nNode Name: 'y'\nType: input\nReached by: 6 executions (100.0%)\nAverage time to reach: 3 seconds\nFlow ends here: 0 executions (0.0% of all, 0.0% of reached)\n\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n:ok\n```\n\n\"Flow Analytics\" as a code-friendly datastructure.\n\n```elixir\n# get some analytics for the executions flowing through the system: how many, what does the funnel look like\nJourney.Insights.FlowAnalytics.flow_analytics(graph.name, graph.version)\n```\n\n<!-- livebook:{\"output\":true} -->\n\n```\n%{\n  graph_name: \"g1\",\n  graph_version: \"v1\",\n  node_stats: %{\n    nodes: [\n      %{\n        node_type: :compute,\n        node_name: :sum,\n        reached_count: 6,\n        reached_percentage: 100.0,\n        average_time_to_reach: 8,\n        flow_ends_here_count: 0,\n        flow_ends_here_percentage_of_all: 0.0,\n        flow_ends_here_percentage_of_reached: 0.0\n      },\n      %{\n        node_type: :input,\n        node_name: :x,\n        reached_count: 6,\n        reached_percentage: 100.0,\n        average_time_to_reach: 8,\n        flow_ends_here_count: 0,\n        flow_ends_here_percentage_of_all: 0.0,\n        flow_ends_here_percentage_of_reached: 0.0\n      },\n      %{\n        node_type: :input,\n        node_name: :y,\n        reached_count: 6,\n        reached_percentage: 100.0,\n        average_time_to_reach: 3,\n        flow_ends_here_count: 0,\n        flow_ends_here_percentage_of_all: 0.0,\n        flow_ends_here_percentage_of_reached: 0.0\n      }\n    ]\n  },\n  analyzed_at: \"2025-08-22T03:28:04.202091Z\",\n  executions: %{\n    count: 6,\n    duration_median_seconds_to_last_update: 1,\n    duration_avg_seconds_to_last_update: 8\n  }\n}\n```","ref":"basic.html#flow-analytics-see-user-s-progression"},{"type":"extras","title":"In summary - Building a resilient application with Journey","doc":"This showed:\n\n* an application defined as a graph + business logic (the function attached to `compute` nodes),\n* an execution of the flow take place, step by step,\n* an execution of the flow be interrupted and resumed, as if nothing happened,\n* analytics describing the \"funnel\" of executions of your graph,\n\nBehind the scenes (not visible in this simple example):\n\n* computations were subject to a retry policy and retries in case of failures,\n* computations scale seamlessly: they run on any replica of your application.\n\nThis all happened without application data getting shipped to a third party, or requiring a SAAS dependency.\n\nSee [Journey documentation](https://hexdocs.pm/journey) for examples of more complex applications (e.g. a Horoscope app, or a Credit Card Application flow, which includes Mutations, and one-time and recurring Scheduled events).\n\n<!-- livebook:{\"offset\":20603,\"stamp\":{\"token\":\"XCP.FG0kKFoVSriLtgqWKPOkvDH9_7Iz6tAdScMYylbjg3wEkLrG6ZYjqW2-Q318JAgzv1rsW0meHAOyvqWuRIg_NNBX6Kx3uaX3S8A_mveoVcJo9W-K1FLSpqdJ\",\"version\":2}} -->","ref":"basic.html#in-summary"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}